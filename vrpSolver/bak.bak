
# [Constructing]
def twMovingSegIntersectPolyLatLon(
    segLatLon:  "Line segment that is moving - no rotation" = None,
    polyLatLon: "Polygon that is moving - no rotation" = None,
    vecPolarSeg: "Moving speed vector of the line segment" = None,
    vecPolarPoly: "Moving speed vector of the line segment" = None
    ) -> "":

    # Calculate the time each ep of poly hits the line segment ================
    tw = None
    ts = []
    te = []
    hts = []
    # The ep of poly hitting the segment
    for pt in polyLatLon:
        ht = htMovingPtTowardsLineSegLatLon(
            ptLatLon = pt,
            segLatLon = segLatLon,
            vecPolarPt = vecPolarPoly,
            vecPolarSeg = vecPolarSeg)
        if (ht != None):
            hts.append(ht)
    if (len(hts) >= 2):
        ts.append(min(hts))
        te.append(max(hts))

    # If no
    


    return tw

# [Constructing]
def projSeg2SegXY(
    seg1:       "Line segment to be projected to seg2" = None,
    seg2:       "Line segment that is being projected to" = None,
    vec:        "Vector of projecting" = None
    ) -> "Given a line segment, project it to another line segment, which might give us \
        1) shadowOnSeg2, the part on the line segment being projected \
        2) projFromSeg1, the part of seg1 that has been projected":

    line4Seg1End1 = [seg1[0], [seg1[0][0] + vec[0], seg1[0][1] + vec[1]]]
    line4Seg1End2 = [seg1[1], [seg1[1][0] + vec[0], seg1[1][1] + vec[1]]]
    line4Seg2End1 = [seg2[0], [seg2[0][0] + vec[0], seg2[0][1] + vec[1]]]
    line4Seg2End2 = [seg2[1], [seg2[1][0] + vec[0], seg2[1][1] + vec[1]]]

    projSeg1End1OnLine2 = intLine2Line(line4Seg1End1, seg2)
    projSeg1End2OnLine2 = intLine2Line(line4Seg1End2, seg2)
    projSeg2End1OnSeg1 = intLine2Line(line4Seg2End1, seg1)
    projSeg2End2OnSeg1 = intLine2Line(line4Seg2End2, seg1)

    seg1End1ProjOnSeg2 = isPtOnSeg(projSeg1End1OnLine2, seg2)
    seg1End2ProjOnSeg2 = isPtOnSeg(projSeg1End2OnLine2, seg2)

    # Case 1: both projPt on seg2
    if (seg1End1ProjOnSeg2 and seg1End2ProjOnSeg2):
        return {
            'shadowOnSeg2': [projSeg1End1OnLine2, projSeg1End2OnLine2],
            'projFromSeg1': seg1
        }

    # Case 2: projPt of end1 of seg1 is on seg2, projPt of end2 of seg1 is not on seg2
    elif (seg1End1ProjOnSeg2 and not seg1End2ProjOnSeg2):
        # Case 2.1: projPt of end1 of seg2 is on seg1
        if (projSeg2End1OnSeg1 != None): 
            return {
                'shadowOnSeg2': [seg2[0], projSeg1End1OnLine2],
                'projFromSeg1': [seg1[0], projSeg2End1OnSeg1]
            }
        else:
            return {
                'shadowOnSeg2': [projSeg1End1OnLine2, seg2[1]],
                'projFromSeg1': [projSeg2End1OnSeg1, seg1[1]]
            }

    # Case 3: projPt of end1 of seg1 is not on seg2, projPt of end1 of seg1 is on seg2

    # Case 4: both projPt not on seg2, seg2 not projecting on seg1
    elif (not seg1End1ProjOnSeg2 and not seg1End2ProjOnSeg2):


    # Case 5: both projPt not on seg2, seg2 entirely projecting on seg1
        pass

    return


def heuVRPBackup(
    nodes:      "Dictionary, returns the coordinate of given nodeID, \
                    {\
                        nodeID1: {'loc': (x, y), 'demand': 1, ...}, \
                        nodeID2: {'loc': (x, y), 'demand': 1, ...}, \
                        ... \
                    }" = None, 
    edges:      "1) String (default) 'Euclidean' or \
                 2) String 'LatLon' or \
                 3) Dictionary {(nodeID1, nodeID2): dist, ...} or \
                 4) String 'Grid', will need to add arguments using `edgeArgs`"= "Euclidean",
    edgeArgs:   "If choose 'Grid' as tau option, we need to provide the following dictionary \
                    {\
                        'colRow': (numCol, numRow),\
                        'barriers': [(coordX, coordY), ...], \
                    }" = None,
    depotID:    "DepotID, default to be 0" = 0,
    nodeIDs:    "1) String (default) 'All', or \
                 2) A list of node IDs" = 'All',
    serviceTime:"Service time spent on each customer (will be added into travel matrix)" = 0,
    objective:  "Objective function\
                 1) String, 'Makespan', or\
                 2) String, 'Cost'" = 'Makespan',
    vehicle:    "Dictionary, describing the vehicle situation, \
                 { \
                    'numTruck': number of truck, if not provided, default to be infinite\
                    'capTruck': capacity of truck, if not provided, default to be infinite\
                 }" = None,
    consAlgo:   "1) String 'CWSaving' or \
                 2) String (not available) 'Sweep' or \
                 3) String (not available) " = 'CWSaving',
    impAlgo:    "1) String '3Opt'" = '3Opt'
    ) -> "Use given heuristic methods to get basic Capacitated VRP solution":

    # Define nodeIDs ==========================================================
    if (type(nodeIDs) is not list):
        if (nodeIDs == 'All'):
            nodeIDs = [i for i in nodes]
        else:
            msgError(ERROR_INCOR_NODEIDS) 
            return
    customerID = [i for i in nodeIDs if i != depotID]

    # Initialize demands ======================================================
    demands = {}
    noDemandList = []
    for n in customerID:        
        if ('demand' not in nodes[n]):
            noDemandList.append(n)
            demands[n] = 1
        else:
            demands[n] = nodes[n]['demand']
    if (len(noDemandList) > 0):
        msgWarning("MESSAGE: 'demands' is missing in nodes %s, set to default value (as 1)" % list2String(noDemandList))

    # Define tau ==============================================================
    tau = getTau(nodes, edges, edgeArgs, depotID, nodeIDs, serviceTime)

    # Subroutines =============================================================
    def _consVRPClarkeWright(nodes, depotID, customerID, tau, vehicle):
        # Initial route
        route = {}
        for i in range(len(customerID)):
            route[i] = {
                'route': [depotID, customerID[i], depotID],
                'demand': demands[customerID[i]],
                'length': tau[depotID, customerID[i]] + tau[customerID[i], depotID]
            }

        # vehCap
        if (vehCap == None):
            vehCap = len(nodeIDs) + 1

        # numVeh
        if (numVeh == None):
            numVeh = len(nodeIDs) + 1

        # Initial saving raking
        rankSaving = []
        for i in customerID:
            for j in customerID:
                if (i != j):
                    # Calculate saving for each pair
                    sav = tau[depotID, i] + tau[depotID, j] - tau[i, j]
                    # heapq returns the smallest, so add a negative sign
                    heapq.heappush(rankSaving, (-sav, (i, j)))

        # Merge route subroutine
        def merge(i, j):
            if (i == j):
                return None
            rI = None
            rJ = None
            iLeft = None
            iRight = None
            jLeft = None
            jRight = None
            for r in route:
                if (i == route[r]['route'][1]):
                    iLeft = True
                    rI = r
                if (i == route[r]['route'][-2]):
                    iRight = True
                    rI = r
                if (j == route[r]['route'][1]):
                    jLeft = True
                    rJ = r
                if (j == route[r]['route'][-2]):
                    jRight = True
                    rJ = r
            newRoute = []
            if (iRight == True and jLeft == True):
                newRoute = [i for i in route[rI]['route']]
                addRoute = [i for i in route[rJ]['route']]
                newRoute.extend(addRoute)
            elif (iLeft == True and jRight == True):
                newRoute = [i for i in route[rJ]['route']]
                addRoute = [i for i in route[rI]['route']]
                newRoute.extend(addRoute)
            elif (iLeft == True and jLeft == True):
                newRoute = [i for i in route[rI]['route']]
                newRoute.reverse()
                addRoute = [i for i in route[rJ]['route']]
                newRoute.extend(addRoute)
            elif (iRight == True and jRight == True):
                newRoute = [i for i in route[rI]['route']]
                addRoute = [i for i in route[rJ]['route']]
                addRoute.reverse()
                newRoute.extend(addRoute)

            while (depotID in newRoute):
                newRoute.remove(depotID)
            newRoute.insert(0, depotID)
            newRoute.append(depotID)

            newDemand = route[rI]['demand'] + route[rJ]['demand']
            newLength = route[rI]['length'] + route[rJ]['length'] + tau[i, j] - tau[depotID, i] - tau[depotID, j]
            route.pop(rI)
            route.pop(rJ)
            newRouteIndex = max(list(route.keys())) + 1
            route[newRouteIndex] = {
                'route': newRoute,
                'demand': newDemand,
                'length': newLength
            }

        # Merge route
        while (len(rankSaving) > 0):
            # Get the biggest saving
            bestSaving = heapq.heappop(rankSaving)
            # Flip it back
            sav = -bestSaving[0]
            # If there is saving, check which two route can be merged
            routeI = None
            routeJ = None
            for r in route:
                if (bestSaving[1][0] == route[r]['route'][1] or bestSaving[1][0] == route[r]['route'][-2]):
                    routeI = r
                if (bestSaving[1][1] == route[r]['route'][1] or bestSaving[1][1] == route[r]['route'][-2]):
                    routeJ = r
                if (routeI != None and routeJ != None):
                    break
            # Two route has to be different, and satisfied the capacity
            if (routeI != None 
                and routeJ != None 
                and routeI != routeJ 
                and route[routeI]['demand'] + route[routeJ]['demand'] <= vehCap
                and len(route) >= numVeh):
                merge(bestSaving[1][0], bestSaving[1][1])

        # Rename the route name
        ofv = 0
        route = {}
        acc = 1
        for r in route:
            ofv += route[r]['length']
            route[acc] = [i for i in route[r]['route']]
            acc += 1

        return {
            'ofv': ofv,
            'route': route
        }
    
    # Solve by different formulations =========================================
    res = None
    if (consAlgo == 'CWSaving'):
        res = _consVRPClarkeWright(nodes, depotID, customerID, tau, vehicle['capTruck'], vehicle['numTruck'])
    else:
        print("Error: Incorrect or unavailable CVRP formulation option!")

    return res
