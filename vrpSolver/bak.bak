
# [Constructing]
def twMovingSegIntersectPolyLatLon(
    segLatLon:  "Line segment that is moving - no rotation" = None,
    polyLatLon: "Polygon that is moving - no rotation" = None,
    vecPolarSeg: "Moving speed vector of the line segment" = None,
    vecPolarPoly: "Moving speed vector of the line segment" = None
    ) -> "":

    # Calculate the time each ep of poly hits the line segment ================
    tw = None
    ts = []
    te = []
    hts = []
    # The ep of poly hitting the segment
    for pt in polyLatLon:
        ht = htMovingPtTowardsLineSegLatLon(
            ptLatLon = pt,
            segLatLon = segLatLon,
            vecPolarPt = vecPolarPoly,
            vecPolarSeg = vecPolarSeg)
        if (ht != None):
            hts.append(ht)
    if (len(hts) >= 2):
        ts.append(min(hts))
        te.append(max(hts))

    # If no
    


    return tw

# [Constructing]
def projSeg2SegXY(
    seg1:       "Line segment to be projected to seg2" = None,
    seg2:       "Line segment that is being projected to" = None,
    vec:        "Vector of projecting" = None
    ) -> "Given a line segment, project it to another line segment, which might give us \
        1) shadowOnSeg2, the part on the line segment being projected \
        2) projFromSeg1, the part of seg1 that has been projected":

    line4Seg1End1 = [seg1[0], [seg1[0][0] + vec[0], seg1[0][1] + vec[1]]]
    line4Seg1End2 = [seg1[1], [seg1[1][0] + vec[0], seg1[1][1] + vec[1]]]
    line4Seg2End1 = [seg2[0], [seg2[0][0] + vec[0], seg2[0][1] + vec[1]]]
    line4Seg2End2 = [seg2[1], [seg2[1][0] + vec[0], seg2[1][1] + vec[1]]]

    projSeg1End1OnLine2 = intLine2Line(line4Seg1End1, seg2)
    projSeg1End2OnLine2 = intLine2Line(line4Seg1End2, seg2)
    projSeg2End1OnSeg1 = intLine2Line(line4Seg2End1, seg1)
    projSeg2End2OnSeg1 = intLine2Line(line4Seg2End2, seg1)

    seg1End1ProjOnSeg2 = isPtOnSeg(projSeg1End1OnLine2, seg2)
    seg1End2ProjOnSeg2 = isPtOnSeg(projSeg1End2OnLine2, seg2)

    # Case 1: both projPt on seg2
    if (seg1End1ProjOnSeg2 and seg1End2ProjOnSeg2):
        return {
            'shadowOnSeg2': [projSeg1End1OnLine2, projSeg1End2OnLine2],
            'projFromSeg1': seg1
        }

    # Case 2: projPt of end1 of seg1 is on seg2, projPt of end2 of seg1 is not on seg2
    elif (seg1End1ProjOnSeg2 and not seg1End2ProjOnSeg2):
        # Case 2.1: projPt of end1 of seg2 is on seg1
        if (projSeg2End1OnSeg1 != None): 
            return {
                'shadowOnSeg2': [seg2[0], projSeg1End1OnLine2],
                'projFromSeg1': [seg1[0], projSeg2End1OnSeg1]
            }
        else:
            return {
                'shadowOnSeg2': [projSeg1End1OnLine2, seg2[1]],
                'projFromSeg1': [projSeg2End1OnSeg1, seg1[1]]
            }

    # Case 3: projPt of end1 of seg1 is not on seg2, projPt of end1 of seg1 is on seg2

    # Case 4: both projPt not on seg2, seg2 not projecting on seg1
    elif (not seg1End1ProjOnSeg2 and not seg1End2ProjOnSeg2):


    # Case 5: both projPt not on seg2, seg2 entirely projecting on seg1
        pass

    return

def heuVRPBackup(
    nodes:      "Dictionary, returns the coordinate of given nodeID, \
                    {\
                        nodeID1: {'loc': (x, y), 'demand': 1, ...}, \
                        nodeID2: {'loc': (x, y), 'demand': 1, ...}, \
                        ... \
                    }" = None, 
    edges:      "1) String (default) 'Euclidean' or \
                 2) String 'LatLon' or \
                 3) Dictionary {(nodeID1, nodeID2): dist, ...} or \
                 4) String 'Grid', will need to add arguments using `edgeArgs`"= "Euclidean",
    edgeArgs:   "If choose 'Grid' as tau option, we need to provide the following dictionary \
                    {\
                        'colRow': (numCol, numRow),\
                        'barriers': [(coordX, coordY), ...], \
                    }" = None,
    depotID:    "DepotID, default to be 0" = 0,
    nodeIDs:    "1) String (default) 'All', or \
                 2) A list of node IDs" = 'All',
    serviceTime:"Service time spent on each customer (will be added into travel matrix)" = 0,
    objective:  "Objective function\
                 1) String, 'Makespan', or\
                 2) String, 'Cost'" = 'Makespan',
    vehicle:    "Dictionary, describing the vehicle situation, \
                 { \
                    'numTruck': number of truck, if not provided, default to be infinite\
                    'capTruck': capacity of truck, if not provided, default to be infinite\
                 }" = None,
    consAlgo:   "1) String 'CWSaving' or \
                 2) String (not available) 'Sweep' or \
                 3) String (not available) " = 'CWSaving',
    impAlgo:    "1) String '3Opt'" = '3Opt'
    ) -> "Use given heuristic methods to get basic Capacitated VRP solution":

    # Define nodeIDs ==========================================================
    if (type(nodeIDs) is not list):
        if (nodeIDs == 'All'):
            nodeIDs = [i for i in nodes]
        else:
            msgError(ERROR_INCOR_NODEIDS) 
            return
    customerID = [i for i in nodeIDs if i != depotID]

    # Initialize demands ======================================================
    demands = {}
    noDemandList = []
    for n in customerID:        
        if ('demand' not in nodes[n]):
            noDemandList.append(n)
            demands[n] = 1
        else:
            demands[n] = nodes[n]['demand']
    if (len(noDemandList) > 0):
        msgWarning("MESSAGE: 'demands' is missing in nodes %s, set to default value (as 1)" % list2String(noDemandList))

    # Define tau ==============================================================
    tau = getTau(nodes, edges, edgeArgs, depotID, nodeIDs, serviceTime)

    # Subroutines =============================================================
    def _consVRPClarkeWright(nodes, depotID, customerID, tau, vehicle):
        # Initial route
        route = {}
        for i in range(len(customerID)):
            route[i] = {
                'route': [depotID, customerID[i], depotID],
                'demand': demands[customerID[i]],
                'length': tau[depotID, customerID[i]] + tau[customerID[i], depotID]
            }

        # vehCap
        if (vehCap == None):
            vehCap = len(nodeIDs) + 1

        # numVeh
        if (numVeh == None):
            numVeh = len(nodeIDs) + 1

        # Initial saving raking
        rankSaving = []
        for i in customerID:
            for j in customerID:
                if (i != j):
                    # Calculate saving for each pair
                    sav = tau[depotID, i] + tau[depotID, j] - tau[i, j]
                    # heapq returns the smallest, so add a negative sign
                    heapq.heappush(rankSaving, (-sav, (i, j)))

        # Merge route subroutine
        def merge(i, j):
            if (i == j):
                return None
            rI = None
            rJ = None
            iLeft = None
            iRight = None
            jLeft = None
            jRight = None
            for r in route:
                if (i == route[r]['route'][1]):
                    iLeft = True
                    rI = r
                if (i == route[r]['route'][-2]):
                    iRight = True
                    rI = r
                if (j == route[r]['route'][1]):
                    jLeft = True
                    rJ = r
                if (j == route[r]['route'][-2]):
                    jRight = True
                    rJ = r
            newRoute = []
            if (iRight == True and jLeft == True):
                newRoute = [i for i in route[rI]['route']]
                addRoute = [i for i in route[rJ]['route']]
                newRoute.extend(addRoute)
            elif (iLeft == True and jRight == True):
                newRoute = [i for i in route[rJ]['route']]
                addRoute = [i for i in route[rI]['route']]
                newRoute.extend(addRoute)
            elif (iLeft == True and jLeft == True):
                newRoute = [i for i in route[rI]['route']]
                newRoute.reverse()
                addRoute = [i for i in route[rJ]['route']]
                newRoute.extend(addRoute)
            elif (iRight == True and jRight == True):
                newRoute = [i for i in route[rI]['route']]
                addRoute = [i for i in route[rJ]['route']]
                addRoute.reverse()
                newRoute.extend(addRoute)

            while (depotID in newRoute):
                newRoute.remove(depotID)
            newRoute.insert(0, depotID)
            newRoute.append(depotID)

            newDemand = route[rI]['demand'] + route[rJ]['demand']
            newLength = route[rI]['length'] + route[rJ]['length'] + tau[i, j] - tau[depotID, i] - tau[depotID, j]
            route.pop(rI)
            route.pop(rJ)
            newRouteIndex = max(list(route.keys())) + 1
            route[newRouteIndex] = {
                'route': newRoute,
                'demand': newDemand,
                'length': newLength
            }

        # Merge route
        while (len(rankSaving) > 0):
            # Get the biggest saving
            bestSaving = heapq.heappop(rankSaving)
            # Flip it back
            sav = -bestSaving[0]
            # If there is saving, check which two route can be merged
            routeI = None
            routeJ = None
            for r in route:
                if (bestSaving[1][0] == route[r]['route'][1] or bestSaving[1][0] == route[r]['route'][-2]):
                    routeI = r
                if (bestSaving[1][1] == route[r]['route'][1] or bestSaving[1][1] == route[r]['route'][-2]):
                    routeJ = r
                if (routeI != None and routeJ != None):
                    break
            # Two route has to be different, and satisfied the capacity
            if (routeI != None 
                and routeJ != None 
                and routeI != routeJ 
                and route[routeI]['demand'] + route[routeJ]['demand'] <= vehCap
                and len(route) >= numVeh):
                merge(bestSaving[1][0], bestSaving[1][1])

        # Rename the route name
        ofv = 0
        route = {}
        acc = 1
        for r in route:
            ofv += route[r]['length']
            route[acc] = [i for i in route[r]['route']]
            acc += 1

        return {
            'ofv': ofv,
            'route': route
        }
    
    # Solve by different formulations =========================================
    res = None
    if (consAlgo == 'CWSaving'):
        res = _consVRPClarkeWright(nodes, depotID, customerID, tau, vehicle['capTruck'], vehicle['numTruck'])
    else:
        print("Error: Incorrect or unavailable CVRP formulation option!")

    return res

def swap2NeighborNodes(
    seq:        "A given sequence of vehicle route, assuming this route is feasible",
    tau:        "Traveling cost matrix", 
    i:          "Index in the sequence, will swap i and i + 1 in the route, 0 <= i <= len(seq) - 1",     
    cost:       "Total cost before swapping, if we need to calculate the new cost, input this value, otherwise newCost will be None" = None,
    revCost:    "Reversed cost before swapping, it is possible that after swapping, the revered route is preferable" = None,
    asymFlag:   "True if asymmetric" = False
    ) -> "Swap the ith and (i+1)th visit in the sequence, if it is applicable, notice that for asymmetric tau, the result is the same":

    # Before: ... --> nIPrev -> nI -> nJ -> nJNext --> ...
    # After:  ... --> nIPrev -> nJ -> nI -> nJNext --> ...
    N = len(seq)
    nIPrev = seq[iterSeq(N, i, 'prev')]
    nI = seq[i]
    nJ = seq[iterSeq(N, i, 'next')]
    nJNext = seq[iterSeq(N, iterSeq(N, i, 'next'), 'next')]

    # Check if can swap
    # Flag that swapping is feasible
    canSwapFlag = True
    # Flag that reversed of swapped seq is feasible and need to consider, will be False if not asymmetric
    canRevSwapFlag = asymFlag

    # If any one of the new links is not available, swapping is not available
    if ((nIPrev, nJ) not in tau or (nJ, nI) not in tau or (nI, nJNext) not in tau):
        canSwapFlag = False
    if (asymFlag):
        if ((nJNext, nI) not in tau or (nI, nJ) not in tau or (nJ, nIPrev) not in tau):
            canRevSwapFlag = False

    # Early quit
    if (not canSwapFlag and not canRevSwapFlag):
        return None

    # newSeq
    newSeq = [k for k in seq]
    j = iterSeq(N, i, 'next')
    newSeq[i], newSeq[j] = newSeq[j], newSeq[i]
    newRevSeq = []
    if (asymFlag and canRevSwapFlag):
        newRevSeq = [newSeq[len(newSeq) - 1 - i] for i in range(len(newSeq))]

    # Calculate deltaCost
    newCost = None
    newRevCost = None
    reverseFlag = False

    # If not asymmetric, only one situation possible, so directly calculate deltaCost
    if (not asymFlag):
        deltaCost = ((tau[nIPrev, nJ] + tau[nJ, nI] + tau[nI, nJNext])
                   - (tau[nIPrev, nI] + tau[nI, nJ] + tau[nJ, nJNext]))
        # For the case that we do not need to calculate the total cost, let them be None
        if (cost == None):
            newCost = None
            newRevCost = None
        else:
            if (cost != None):
                newCost = cost + deltaCost
                newRevCost = None

    # If asymmetric, the following cases need to be considered:
    # 1. newSeq feasible + newRevSeq feasible => deltaCost: min(newRevCost, newCost) - cost
    #    - newCost is better
    #    - newRevCost is better, need to take the reversed seq as a new seq
    # 2. newSeq infeasible + newRevSeq feasible => deltaCost: newRevCost - cost
    #    - need to take the reversed seq as a new seq
    # 3. newSeq feasible + newRevSeq infeasible => deltaCost: newCost - cost
    #    - same as symmetric
    else:
        if (canSwapFlag):
            if (cost != None):
                newCost = (cost - (tau[nIPrev, nI] + tau[nI, nJ] + tau[nJ, nJNext])
                                + (tau[nIPrev, nJ] + tau[nJ, nI] + tau[nI, nJNext]))
            else:
                newCost = calSeqCostMatrix(
                    tau = tau,
                    seq = newSeq,
                    closeFlag = True)
                if (newCost == None):
                    canSwapFlag = False
        if (canRevSwapFlag):
            # NOTE: if revCost != None, it means the reverse seq is feasible, no need to check the links
            if (revCost != None):
                newRevCost = (revCost - (tau[nJNext, nJ] + tau[nJ, nI] + tau[nI, nIPrev])
                                      + (tau[nJNext, nI] + tau[nI, nJ] + tau[nJ, nIPrev]))
            else:
                newRevCost = calSeqCostMatrix(
                    tau = tau,
                    seq = newRevSeq,
                    closeFlag = True)
                if (newRevCost == None):
                    canRevSwapFlag = False

        # Case 1
        if (canSwapFlag and canRevSwapFlag):
            deltaCost1 = newCost - cost
            deltaCost2 = newRevCost - cost
            if (deltaCost1 <= deltaCost2):
                deltaCost = deltaCost1
            else:
                deltaCost = deltaCost2
                newSeq = [i for i in newRevSeq]
                reverseFlag = True
                newCost, newRevCost = newRevCost, newCost
        # Case 2
        elif (not canSwapFlag and canRevSwapFlag):
            deltaCost = newRevCost - cost
            newSeq = [i for i in newRevSeq]
            reverseFlag = True
            newCost, newRevCost = newRevCost, newCost
        # Case 3
        elif (canSwapFlag and not canRevSwapFlag):
            deltaCost = newCost - cost

    # NOTE: If deltaCost < 0, it means the route is improved after swapping

    return {
        'seq': newSeq,
        'deltaCost': deltaCost,
        'reversed': reverseFlag,
        'newCost': newCost,
        'newRevCost': newRevCost
    }

def exchange2Nodes(
    seq:        "A given sequence of vehicle route, assuming this route is feasible", 
    tau:        "Traveling cost matrix", 
    i:          "Index in the sequence, 0 <= i <= len(seq) - 1", 
    j:          "Index in the sequence, 0 <= i <= len(seq) - 1, i != j",     
    cost:       "Total cost before swapping, if we need to calculate the new cost, input this value, otherwise newCost will be None" = None,
    revCost:    "Reversed cost before swapping, it is possible that after swapping, the revered route is preferable" = None,
    asymFlag:   "True if asymmetric" = False
    ) -> "Swap the ith and jth visit in the sequence, if it is applicable, notice that for asymmetric tau, the result is the same":

    # Before: ... --> nIPrev -> nI -> nINext --> ... --> nJPrev -> nJ -> nJNext --> ...
    # After:  ... --> nIPrev -> nJ -> nINext --> ... --> nJPrev -> nI -> nJNext --> ...
    N = len(seq)
    nIPrev = seq[iterSeq(N, i, 'prev')]
    nI = seq[i]
    nINext = seq[iterSeq(N, i, 'next')]
    nJPrev = seq[iterSeq(N, j, 'prev')]
    nJ = seq[j]
    nJNext = seq[iterSeq(N, j, 'next')]

    # nINext == nJ
    if (nINext == nJ):
        return swap2NeighborNodes(
            seq = seq,
            tau = tau,
            i = i,
            cost = cost,
            revCost = revCost,
            asymFlag = asymFlag)

    # Check if can exchange
    canExchangeFlag = True
    canRevExchangeFlag = asymFlag

    # If any one of the new links is not available, exchanging is not available
    if ((nIPrev, nJ) not in tau or (nJ, nINext) not in tau or (nJPrev, nI) not in tau or (nI, nJNext) not in tau):
        canExchangeFlag = False
    if (asymFlag):
        if ((nJNext, nI) not in tau or (nI, nJPrev) not in tau or (nINext, nJ) not in tau or (nJ, nIPrev) not in tau):
            canRevExchangeFlag = False

    # Early quit
    if (not canExchangeFlag and not canRevExchangeFlag):
        return None

    # New seq
    newSeq = [k for k in seq]
    newSeq[i], newSeq[j] = newSeq[j], newSeq[i]
    newRevSeq = []
    if (asymFlag and canRevExchangeFlag):
        newRevSeq = [newSeq[len(newSeq) - 1 - i] for i in range(len(newSeq))]

    # Calculate deltaCost
    newCost = None
    newRevCost = None
    reverseFlag = False

    # If not asymmetric, only one situation possible, so directly calculate deltaCost
    if (not asymFlag):
        deltaCost = ((tau[nIPrev, nJ] + tau[nJ, nINext] + tau[nJPrev, nI] + tau[nI, nJNext])
                   - (tau[nIPrev, nI] + tau[nI, nINext] + tau[nJPrev, nJ] + tau[nJ, nJNext]))
        # For the case that we do not need to calculate the total cost, let them be None
        if (cost == None):
            newCost = None
            newRevCost = None
        else:
            if (cost != None):
                newCost = cost + deltaCost
                newRevCost = None

    # If asymmetric, the following cases need to be considered:
    # 1. newSeq feasible + newRevSeq feasible => deltaCost: min(newRevCost, newCost) - cost
    #    - newCost is better
    #    - newRevCost is better, need to take the reversed seq as a new seq
    # 2. newSeq infeasible + newRevSeq feasible => deltaCost: newRevCost - cost
    #    - need to take the reversed seq as a new seq
    # 3. newSeq feasible + newRevSeq infeasible => deltaCost: newCost - cost
    #    - same as symmetric
    else:
        if (canExchangeFlag):
            if (cost != None):
                newCost = (cost + tau[nIPrev, nJ] + tau[nJ, nINext] + tau[nJPrev, nI] + tau[nI, nJNext]
                          - (tau[nIPrev, nI] + tau[nI, nINext] + tau[nJPrev, nJ] + tau[nJ, nJNext]))
            else:
                newCost = calSeqCostMatrix(
                    tau = tau,
                    seq = newSeq) 
        if (canRevExchangeFlag):
            # NOTE: if revCost != None, it means the reverse seq is feasible, no need to check the links
            if (revCost != None):
                newRevCost = (revCost + tau[nJNext, nI] + tau[nI, nJPrev] + tau[nINext, nJ] + tau[nJ, nIPrev]
                           - (tau[nJNext, nJ] + tau[nJ, nJPrev] + tau[nINext, nI] + tau[nI, nIPrev]))
            else:
                newRevCost = calSeqCostMatrix(
                    tau = tau,
                    seq = newRevSeq)
                if (newRevCost == None):
                    canRevExchangeFlag = False

        # Case 1
        if (canExchangeFlag and canRevExchangeFlag):
            deltaCost1 = newCost - cost
            deltaCost2 = newRevCost - cost
            if (deltaCost1 <= deltaCost2):
                deltaCost = deltaCost1
            else:
                deltaCost = deltaCost2
                newSeq = newRevSeq
                reverseFlag = True
                newCost, newRevCost = newRevCost, newCost
        # Case 2
        elif (not canExchangeFlag and canRevExchangeFlag):
            deltaCost = newRevCost - cost
            newSeq = newRevSeq
            reverseFlag = True
            newCost, newRevCost = newRevCost, newCost
        # Case 3
        elif (canExchangeFlag and not canRevExchangeFlag):
            deltaCost = newCost - cost

    return {
        'seq': newSeq,
        'deltaCost': deltaCost,
        'reversed': reverseFlag,
        'newCost': newCost,
        'newRevCost': newRevCost
    }

def createWarehouseLayout(
    shelfCol:   "Integer, Number of columns in the warehouse layout" = 5,
    shelfRow:   "Integer, Number of rows in warehouse layout" = 10,
    shelfWidth: "Integer, Width of shelf" = 1,
    shelfDeep:  "Integer, Number of deeps of the shelf" = 1,
    aisleWidth: "Integer, Width of the aisles" = 1,
    layoutType: "1) String, 'Traditional' or\
                 2) String, 'CrossAisle'" = 'CrossAisle',
    RSPointType: "1) String, 'BottomMiddle' or\
                 2) String, 'LeftMiddle' or\
                 3) String, 'Corner'" = 'BottomMiddle'
    ) -> "Create the travel network and the grid":

    # Initialize ==============================================================
    dicLayout = {}

    # Metadata ================================================================
    dicLayout['meta'] = {
        'shelfCol': shelfCol,
        'shelfRow': shelfRow,
        'shelfWidth': shelfWidth,
        'shelfDeep': shelfDeep,
        'aisleWidth': aisleWidth,
        'layoutType': layoutType,
        'RSPointType': RSPointType
    }

    # Create grids ============================================================
    dicLayout['grid'] = {}
    numCol = aisleWidth + (shelfWidth * shelfDeep + aisleWidth) * shelfCol
    numRow = aisleWidth * 2 + shelfWidth * shelfRow + aisleWidth * (1 if layoutType == 'CrossAisle' else 0)
    dicLayout['grid']['colRow'] = (numCol, numRow)
    dicLayout['grid']['barriers'] = []
    if (layoutType == 'Traditional'):
        for i in range(1, shelfRow + 1):
            for j in range(shelfCol):
                for d in range(shelfDeep):
                    dicLayout['grid']['barriers'].append((aisleWidth + (shelfDeep * shelfWidth + aisleWidth) * j + shelfWidth * d, i))
    elif (layoutType == 'CrossAisle'):
        for i in range(1, int((shelfRow + 1) / 2) + 1):
            for j in range(shelfCol):
                for d in range(shelfDeep):
                    dicLayout['grid']['barriers'].append((aisleWidth + (shelfDeep * shelfWidth + aisleWidth) * j + shelfWidth * d, i))
        for i in range(int((shelfRow + 1) / 2) + 2, shelfRow + 2):
            for j in range(shelfCol):
                for d in range(shelfDeep):
                    dicLayout['grid']['barriers'].append((aisleWidth + (shelfDeep * shelfWidth + aisleWidth) * j + shelfWidth * d, i))

    # Create RS location ======================================================
    RSX = None
    RSY = None
    if (RSPointType == 'BottomMiddle'):
        RSX = (aisleWidth + (aisleWidth + shelfDeep * shelfWidth) * shelfCol) / 2
        RSY = aisleWidth / 2
        dicLayout['RSGridID'] = (int((aisleWidth + (aisleWidth + shelfDeep * shelfWidth) * shelfCol) / 2), 0)
    elif (RSPointType == 'LeftMiddle'):
        RSX = aisleWidth / 2
        RSY = (aisleWidth * 2 + shelfWidth * shelfRow + (aisleWidth if layoutType == 'CrossAisle' else 0)) / 2
        dicLayout['RSGridID'] = (0, int((aisleWidth * 2 + shelfWidth * shelfRow + (aisleWidth if layoutType == 'CrossAisle' else 0)) / 2))
    elif (RSPointType == 'Corner'):
        RSX = aisleWidth / 2
        RSY = aisleWidth / 2
        dicLayout['RSGridID'] = (0, 0)
    dicLayout['RS'] = [RSX, RSY]

    # Create shelves ==========================================================
    dicLayout['shelf'] = {}
    shelfID = 1
    for col in range(shelfCol):
        for row in range(shelfRow):
            for deep in range(shelfDeep):
                topLeftX = aisleWidth + col * (aisleWidth + shelfDeep * shelfWidth) + deep * shelfWidth
                topTopY = None
                if (layoutType == 'Traditional'):
                    topTopY = aisleWidth + shelfWidth + row * shelfWidth
                elif (layoutType == 'CrossAisle'):
                    if (row < shelfRow / 2):
                        topTopY = aisleWidth + shelfWidth + row * shelfWidth
                    else:
                        topTopY = 2 * aisleWidth + shelfWidth + row * shelfWidth
                poly = [[topLeftX, topTopY], 
                        [topLeftX, topTopY - shelfWidth], 
                        [topLeftX + shelfWidth, topTopY - shelfWidth], 
                        [topLeftX + shelfWidth, topTopY]]
                dicLayout['shelf'][shelfID] = {
                    'poly': poly,
                    'rowID': row,
                    'colID': col,
                    'deepID': deep
                }
                shelfID += 1

    # For the boundary ========================================================
    dicLayout['boundary'] = {}
    dicLayout['boundary']['ploy'] = [
        [0, 0], 
        [aisleWidth + (aisleWidth + shelfDeep * shelfWidth) * shelfCol, 0],
        [aisleWidth + (aisleWidth + shelfDeep * shelfWidth) * shelfCol, aisleWidth * 2 + shelfWidth * shelfRow + (aisleWidth if layoutType == 'CrossAisle' else 0)],
        [0, aisleWidth * 2 + shelfWidth * shelfRow + (aisleWidth if layoutType == 'CrossAisle' else 0)]        
    ]   

    return dicLayout


def plotStep(
    fig:        "Based matplotlib figure object" = None, 
    ax:         "Based matplotlib ax object" = None,
    step:       "List of dictionaries, in the following format\
                    [{\
                        'resID': resource ID, \
                        'timeStamp': list of time stamps, \
                        'useLevel': number of resource that are been used after correspond time stamp, \
                        'color': (optional, default as 'random') color, \
                        'style': (optional, default as 'solid') 'solid' \
                    }, ... , ]\
                " = None,
    stepInt:    "Interval of stat" = 1,
    showPercentageFlag: "True if show the percentage of time for each level" = True,
    gridFlag:   "True if turn on the grid as background" = True,
    labelFlag:  "True if add label of entities on Gantt chart" = True,
    linewidth:  "The width of step block borders" = 1,
    entities:   "1) None, takes the entities in `step` \
                 2) List of Strings, the step chart will be drawn in this order" = None,
    startTime:  "Start time of step, default to be 0, if None, use the earliest time in `step`" = 0,
    endTime:    "End time of step, default to be None, if None, use the latest time in `step`" = None,
    showTail:   "Show the latest time of all step blocks" = True,
    figSize:    "Size of the figure, in (width, height)" = (12, 5),
    saveFigPath:"1) None, if not exporting image, or \
                 2) String, the path for exporting image" = None,
    showFig:    "True if shows the figure in environment such as Jupyter Notebook, \
                 recommended to turn off if generate a batch of images" = True
    ) -> "Given a step dictionary, plot step chart":

    # Check for required fields ===============================================
    if (step == None):
        msgError(ERROR_MISSING_STEP)
        return

    # Pre-calculate ===========================================================
    realStart = None
    realEnd = None
    resList = []
    for st in step:
        if (st['resID'] not in resList):
            resList.append(st['resID'])

        for t in st['timeStamp']:
            if (realStart == None or realStart > st['timeStamp'][0]):
                realStart = st['timeStamp'][0]
            if (realEnd == None or realEnd < st['timeStamp'][-1]):
                realEnd = st['timeStamp'][-1]
    if (entities != None):
        for e in entities:
            if (e not in resList):
                msgError(ERROR_INCOR_GANTT_MISSENT)
                return
    elif (entities == None):
        entities = [i for i in resList]

    # Check overwritten fields ================================================
    if (startTime != None):
        startTime = startTime
    else:
        startTime = realStart

    if (endTime != None):
        endTime = endTime
    else:
        endTime = realEnd

    # If no based matplotlib figure, define fig size ==========================
    if (fig == None or ax == None):
        fig, ax = plt.subplots()
        fig.set_figwidth(figSize[0])
        ax.set_xlim(startTime, endTime + (endTime - startTime) * 0.05)

    # Set axis ================================================================
    rangeByEntity = {}
    for st in step:
        rangeByEntity[st['resID']] = [min(st['useLevel']), max(st['useLevel'])]

    entities.reverse()
    # yticks = []

    btm = {}
    yticks = [0]
    yticklabels = [0]
    accBtm = 0
    for i in range(len(entities)):
        btm[entities[i]] = accBtm
        if (accBtm + rangeByEntity[entities[i]][0] != yticks[-1]):
            yticks.append(accBtm + rangeByEntity[entities[i]][0])
            yticklabels.append(rangeByEntity[entities[i]][0])
        for j in range(math.ceil(rangeByEntity[entities[i]][0]), math.floor(rangeByEntity[entities[i]][1])):
            yticks.append(accBtm + j)
            yticklabels.append(j)

        accBtm += rangeByEntity[entities[i]][1] - rangeByEntity[entities[i]][0]
        if (rangeByEntity[entities[i]][1] != yticklabels[-1]):
            yticks.append(accBtm)
            yticklabels.append(rangeByEntity[entities[i]][1])
        accBtm += 1 # Space between step charts

    ax.set_yticks(yticks)
    # entities.reverse()
    ax.set_yticklabels(yticklabels)
    entities.reverse()
    ax.set_xlabel("Time")

    if (fig == None and ax == None):
        ax.set_ylim(0, accBtm)

    # Grids ===================================================================
    if (gridFlag):
        ax.grid(b = True, linestyle=':')

    # Loop through `step` and draw step chart =================================
    for st in step:
        if (st['resID'] in resList):
            bottom = btm[st['resID']]
            polyX = [realStart]
            polyY = [bottom]
            polyX = [st['timeStamp'][0]]
            polyY = [bottom]
            for i in range(len(st['timeStamp']) - 1):
                polyX.append(st['timeStamp'][i])
                polyY.append(bottom + st['useLevel'][i] - rangeByEntity[st['resID']][0])
                polyX.append(st['timeStamp'][i + 1])
                polyY.append(bottom + st['useLevel'][i] - rangeByEntity[st['resID']][0])
            polyX.append(st['timeStamp'][-1])
            polyY.append(bottom + st['useLevel'][-1])
            if (st['timeStamp'][-1] >= realEnd):
                polyX.append(realEnd)
                polyY.append(bottom)

            ax.plot(polyX, polyY, color = 'black', linewidth = linewidth)            
            if ('color' in st and st['color'] != 'random'):
                ax.fill(polyX, polyY, color = st['color'], linewidth = linewidth)
                ax.annotate(st['resID'], (0, bottom + 0.1))
            else:
                rndColor = colorRandom()
                ax.fill(polyX, polyY, color = str(rndColor), linewidth = linewidth)
                ax.annotate(st['resID'], (0, bottom + 0.1), color = 'black')
            if ('style' in st and st['style'] != 'solid'):
                ax.fill(polyX, polyY, hatch = st['style'], fill=False, linewidth = linewidth)

    # Show percentage =========================================================
    if (showPercentageFlag):
        # Get stat
        stStatScale = {}
        for st in step:
            if (st['resID'] in resList):
                stStatScale[st['resID']] = []
                for r in range(0, math.ceil(rangeByEntity[st['resID']][1] - rangeByEntity[st['resID']][0]), stepInt):
                    rangeStat = [rangeByEntity[st['resID']][0] + r * stepInt, rangeByEntity[st['resID']][0] + (r + 1) * stepInt]
                    stStatScale[st['resID']].append({
                        'rangeStat': rangeStat,
                        'totalLength': 0
                    })
                for i in range(len(st['timeStamp']) - 1):
                    lengthOfLevel = st['timeStamp'][i + 1] - st['timeStamp'][i]
                    for j in range(len(stStatScale[st['resID']])):
                        if (st['useLevel'][i] > stStatScale[st['resID']][j]['rangeStat'][0] and st['useLevel'][i] <= stStatScale[st['resID']][j]['rangeStat'][1]):
                            stStatScale[st['resID']][j]['totalLength'] += lengthOfLevel
        # Plot Stat
        for st in step:
            if (st['resID'] in resList):
                for stat in stStatScale[st['resID']]:
                    note = "[" + str(stat['rangeStat'][0]) + ", " + str(stat['rangeStat'][1]) + "]: " + str(round(stat['totalLength'] / realEnd * 100, 2)) + "%"
                    ax.annotate(note, (ax.get_xlim()[1] + 5, 0.1 + btm[st['resID']] + stat['rangeStat'][0]))

    # Show time span ==========================================================
    if (showTail):
        xTicks = list(ax.get_xticks())
        xTicks.append(realEnd)
        ax.set_xticks(xTicks)  

    # Fix height if fig, ax are not provided ==================================
    if (fig == None or ax == None):
        fig.set_figheight(5 * len(entities))

    # Save figure =============================================================
    if (saveFigPath != None):
        fig.savefig(saveFigPath)
    if (not showFig):
        plt.close(fig)
    return fig, ax

def plotGrid(
    fig:        "Based matplotlib figure object" = None,
    ax:         "Based matplotlib ax object" = None,
    gridColRow: "Number of columns, and number of rows" = (None, None),
    barriers:   "List of blocking grids" = [],
    labeling:   "Additional labeling of grids to support different color or annotation, in format of \
                    {\
                        (coordX, coordY): { \
                            'color': color, \
                            'annotation': annotation \
                        }\
                    }" = None,
    gridSize:   "Size of the grid" = 1,
    gridBackColor: "Background color of grids" = None,
    gridEdgeColor: "Edge color of grids" = 'black',
    gridOpacity: "Opacity of grids background colors" = 1,
    barrierBackColor: "Background color of barriers" = 'gray',
    barrierEdgeColor: "Edge color of barriers" = 'black',
    barrierOpacity: "Opacity of barriers" = 0.5,
    barrierBackStyle: "Background style of barriers" = '///',
    saveFigPath:"1) None, if not exporting image, or \
                 2) String, the path for exporting image" = None,
    showFig:    "True if shows the figure in environment such as Jupyter Notebook, \
                 recommended to turn off if generate a batch of images" = True
    ) -> "Plot a grid with barriers":

    # If no based matplotlib figure, define boundary ==========================
    if (fig == None or ax == None):
        fig, ax = plt.subplots()
        xMin = (0 - 0.5) * gridSize
        yMin = (0 - 0.5) * gridSize
        xMax = (gridColRow[0] + 0.5) * gridSize
        yMax = (gridColRow[1] + 0.5) * gridSize
        fig.set_figwidth(xMax)
        fig.set_figheight(yMax)
        ax.set_xlim(xMin, xMax)
        ax.set_ylim(yMin, yMax)
        plt.axis('off')

    for col in range(gridColRow[0]):
        for row in range(gridColRow[1]):
            poly = [
                [col * gridSize, row * gridSize], 
                [col * gridSize + gridSize, row * gridSize],
                [col * gridSize + gridSize, row * gridSize + gridSize],
                [col * gridSize, row * gridSize + gridSize],
                [col * gridSize, row * gridSize]
            ]
            if ((col, row) not in barriers):
                plotPolygon(
                    fig = fig,
                    ax = ax,
                    poly = poly,
                    edgeColor = gridEdgeColor,
                    fillColor = gridBackColor,
                    opacity = gridOpacity)
            else:
                plotPolygon(
                    fig = fig,
                    ax = ax,
                    poly = poly,
                    edgeColor = barrierEdgeColor,
                    fillColor = barrierBackColor,
                    opacity = barrierOpacity,
                    fillStyle = barrierBackStyle)

    # Add labels ==============================================================
    if (labeling != None):
        for (col, row) in labeling:
            if ('color' in labeling[(col, row)]):
                plotPolygon(
                    fig = fig,
                    ax = ax,
                    poly = poly,
                    edgeColor = gridEdgeColor,
                    fillColor = labeling[(col, row)]['color'],
                    opacity = gridOpacity)

    # Save figure =============================================================
    if (saveFigPath != None):
        fig.savefig(saveFigPath)
    if (not showFig):
        plt.close(fig)

    return fig, ax

def plotGridPath(
    fig:        "Based matplotlib figure object" = None,
    ax:         "Based matplotlib ax object" = None,
    gridColRow: "Number of columns, and number of rows" = (None, None),
    barriers:   "List of blocking grids, needed if plotGridFlag is True" = [],
    gridSize:   "Size of the grid" = 1,
    plotGridFlag: "True if plot the grid as background, false otherwise" = True,
    path:       "The sequences of visiting grids, a list of coordinates" = None,
    pathColor:  "The color of path" = 'Random',
    pathWidth:  "The width of path" = 3,
    markerSize: "Size of starting/ending points" = 15,
    saveFigPath:"1) None, if not exporting image, or \
                 2) String, the path for exporting image" = None,
    showFig:    "True if shows the figure in environment such as Jupyter Notebook, \
                 recommended to turn off if generate a batch of images" = True
    ) -> "Plot the path on the grid":

    # If no based matplotlib figure, define boundary ==========================
    if (fig == None or ax == None):
        fig, ax = plt.subplots()
        xMin = (0 - 0.5) * gridSize
        yMin = (0 - 0.5) * gridSize
        xMax = (gridColRow[0] + 0.5) * gridSize
        yMax = (gridColRow[1] + 0.5) * gridSize
        fig.set_figwidth(xMax)
        fig.set_figheight(yMax)
        ax.set_xlim(xMin, xMax)
        ax.set_ylim(yMin, yMax)
        plt.axis('off')

    # Plot grid background ====================================================
    if (plotGridFlag):
        fig, ax = plotGrid(
            fig = fig,
            ax = ax,
            gridColRow = gridColRow,
            barriers = barriers,
            gridSize = gridSize)

    # Path color ==============================================================
    if (pathColor == 'Random'):
        pathColor = colorRandom()

    # Plot the origin/destination =============================================
    ax.plot(path[0][0] * gridSize + gridSize / 2, path[0][1] * gridSize + gridSize / 2, marker = 'o', markersize= markerSize, color = pathColor)
    ax.plot(path[-1][0] * gridSize + gridSize / 2, path[-1][1] * gridSize + gridSize / 2, marker = 's', markersize= markerSize, color = pathColor)
    for i in range(len(path) - 1):
        x = [path[i][0] * gridSize + gridSize / 2, path[i + 1][0] * gridSize + gridSize / 2]
        y = [path[i][1] * gridSize + gridSize / 2, path[i + 1][1] * gridSize + gridSize / 2]
        ax.plot(x, y, color = pathColor, linewidth = pathWidth)

    # Save figure =============================================================
    if (saveFigPath != None):
        fig.savefig(saveFigPath)
    if (not showFig):
        plt.close(fig)

    return fig, ax
