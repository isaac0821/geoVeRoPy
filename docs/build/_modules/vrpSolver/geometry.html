<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>vrpSolver.geometry &#8212; vrpSolver 0.0.56 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b849a4e9" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinxdoc.css?v=87629129" />
    <script src="../../_static/documentation_options.js?v=8f83b1af"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">vrpSolver 0.0.56 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">vrpSolver.geometry</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for vrpSolver.geometry</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">geopy.distance</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">tripy</span>

<span class="kn">import</span> <span class="nn">shapely</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">mapping</span>
<span class="kn">from</span> <span class="nn">shapely.ops</span> <span class="kn">import</span> <span class="n">nearest_points</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="kn">from</span> <span class="nn">.common</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.msg</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.ds</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Point versus Objects ========================================================</span>
<div class="viewcode-block" id="is2PtsSame">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.is2PtsSame">[docs]</a>
<span class="k">def</span> <span class="nf">is2PtsSame</span><span class="p">(</span><span class="n">pt1</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">pt2</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">error</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Are two points at the &#39;same&#39; location?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt1: pt, required</span>
<span class="sd">        Coordinate of the first point</span>
<span class="sd">    pt2: pt, required</span>
<span class="sd">        Coordinate of the second point</span>
<span class="sd">    error: float, optional, default as CONST_EPSILON</span>
<span class="sd">        Error tolerance</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if two points are at the same location, False else-wise</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">error</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">error</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="is3PtsClockWise">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.is3PtsClockWise">[docs]</a>
<span class="k">def</span> <span class="nf">is3PtsClockWise</span><span class="p">(</span><span class="n">pt1</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">pt2</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">pt3</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">error</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Are three given pts in a clock-wise order, None as they are collinear</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt1: pt, required</span>
<span class="sd">        Coordinate of the first point</span>
<span class="sd">    pt2: pt, required</span>
<span class="sd">        Coordinate of the second point</span>
<span class="sd">    pt3: pt, required</span>
<span class="sd">        Coordinate of the third point</span>
<span class="sd">    error: float, optional, default as CONST_EPSILON</span>
<span class="sd">        Error tolerance</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool | None</span>
<span class="sd">        True if three given points are in a clock-wise order, False if they are in counter-clock-wise order, None if they are collinear</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is2PtsSame</span><span class="p">(</span><span class="n">pt2</span><span class="p">,</span> <span class="n">pt3</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is2PtsSame</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt3</span><span class="p">)):</span>
        <span class="c1"># If points are overlapped, return None as collinear</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="p">[</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="p">[</span><span class="n">x3</span><span class="p">,</span> <span class="n">y3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt3</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">ori</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y3</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x3</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span>
    <span class="c1"># collinear</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">ori</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">error</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="c1"># clockwise </span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">ori</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>        
        <span class="k">return</span> <span class="kc">True</span>
    <span class="c1"># counter-clockwise</span>
    <span class="k">else</span><span class="p">:</span>        
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="isPtOnLine">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isPtOnLine">[docs]</a>
<span class="k">def</span> <span class="nf">isPtOnLine</span><span class="p">(</span><span class="n">pt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">error</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a pt on the line?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt: pt, required</span>
<span class="sd">        Coordinate of the point</span>
<span class="sd">    line: line, required</span>
<span class="sd">        Two coordinates to form a line</span>
<span class="sd">    error: float, optional, default as CONST_EPSILON</span>
<span class="sd">        Error tolerance</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if the point is on the line, False else-wise</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ZeroVectorError</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is3PtsClockWise</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">)</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="isPtOnSeg">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isPtOnSeg">[docs]</a>
<span class="k">def</span> <span class="nf">isPtOnSeg</span><span class="p">(</span><span class="n">pt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">seg</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">error</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a pt on the lines segment?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt: pt, required</span>
<span class="sd">        Coordinate of the point</span>
<span class="sd">    seg: line, required</span>
<span class="sd">        Two coordinates to form a line segment</span>
<span class="sd">    interiorOnly: bool, optional, default as False</span>
<span class="sd">        True if only consider intersecting in the interior</span>
<span class="sd">    error: float, optional, default as CONST_EPSILON</span>
<span class="sd">        Error tolerance</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if the point is on the line segment, False else-wise</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">onLine</span> <span class="o">=</span> <span class="n">isPtOnLine</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">onLine</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># Get pts =================================================================</span>
    <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
    <span class="p">[</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="p">[</span><span class="n">x3</span><span class="p">,</span> <span class="n">y3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
    <span class="c1"># NOTE: 判断在线段上的标准为到两端点的距离的和等于端点间距离</span>
    <span class="n">onSeg</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">abs</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> 
        <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> 
        <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">error</span><span class="p">)</span>
    <span class="c1"># Check if the intersection is in the interior ============================</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">interiorOnly</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">onSeg</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is2PtsSame</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is2PtsSame</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">onSeg</span></div>


<div class="viewcode-block" id="isPtOnRay">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isPtOnRay">[docs]</a>
<span class="k">def</span> <span class="nf">isPtOnRay</span><span class="p">(</span><span class="n">pt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">ray</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a pt on the ray?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt: pt, required</span>
<span class="sd">        Coordinate of the point</span>
<span class="sd">    ray: line, required</span>
<span class="sd">        Two coordinates to form a line segment</span>
<span class="sd">    interiorOnly: bool, optional, default as False</span>
<span class="sd">        True if only consider intersecting in the interior</span>
<span class="sd">    error: float, optional, default as CONST_EPSILON</span>
<span class="sd">        Error tolerance</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if the point is on the line segment, False else-wise</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">onLine</span> <span class="o">=</span> <span class="n">isPtOnLine</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">ray</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">onLine</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># Get pts =================================================================</span>
    <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
    <span class="p">[</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="p">[</span><span class="n">x3</span><span class="p">,</span> <span class="n">y3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ray</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ray</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">onRay</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> 
            <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> 
            <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">error</span><span class="p">)</span>
        <span class="ow">or</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="c1"># Check if the intertion is in the interior ===============================</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">interiorOnly</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">onRay</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is2PtsSame</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">onRay</span></div>


<div class="viewcode-block" id="isPtOnPolyEdge">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isPtOnPolyEdge">[docs]</a>
<span class="k">def</span> <span class="nf">isPtOnPolyEdge</span><span class="p">(</span><span class="n">pt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">poly</span><span class="p">:</span> <span class="n">poly</span><span class="p">,</span> <span class="n">error</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a pt on the edge of the polygon?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt: pt, required</span>
<span class="sd">        Coordinate of the point</span>
<span class="sd">    poly: poly, required</span>
<span class="sd">        The polygon</span>
<span class="sd">    error: float, optional, default as CONST_EPSILON</span>
<span class="sd">        Error tolerance</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if the point is on the line segment, False else-wise</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check if the pt is on any of the edge segment ===========================</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isPtOnSeg</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="p">[</span><span class="n">poly</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">poly</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">error</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="isPtInPoly">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isPtInPoly">[docs]</a>
<span class="k">def</span> <span class="nf">isPtInPoly</span><span class="p">(</span><span class="n">pt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">poly</span><span class="p">:</span> <span class="n">poly</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">error</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a pt in the polygon?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt: pt, required</span>
<span class="sd">        Coordinate of the point</span>
<span class="sd">    poly: poly, required</span>
<span class="sd">        The polygon</span>
<span class="sd">    interiorOnly: bool, optional, default as False</span>
<span class="sd">        True if only consider intersecting in the interior</span>
<span class="sd">    error: float, optional, default as CONST_EPSILON</span>
<span class="sd">        Error tolerance</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if the point is on the line segment, False else-wise</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">inPoly</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># NOTE: 忘记这段魔法是从哪里来的了...</span>
    <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)):</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">poly</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="n">poly</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xj</span> <span class="o">=</span> <span class="n">poly</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">yj</span> <span class="o">=</span> <span class="n">poly</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">intersect</span> <span class="o">=</span> <span class="p">(</span><span class="n">yi</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">yj</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">intersect</span><span class="p">):</span>
            <span class="n">intersect</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">xj</span> <span class="o">-</span> <span class="n">xi</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">yi</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">yj</span> <span class="o">-</span> <span class="n">yi</span><span class="p">)</span> <span class="o">+</span> <span class="n">xi</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">intersect</span><span class="p">):</span>
            <span class="n">inPoly</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">inPoly</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
    <span class="c1"># Check if the intertion is in the interior ===============================</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">interiorOnly</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">inPoly</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isPtOnPolyEdge</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">inPoly</span></div>


<span class="c1"># Point to line-shape =========================================================</span>
<div class="viewcode-block" id="rayPerp2Line">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.rayPerp2Line">[docs]</a>
<span class="k">def</span> <span class="nf">rayPerp2Line</span><span class="p">(</span><span class="n">pt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">line</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a point and a line, return a ray from that point and perpendicular to the given line</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt: pt, required</span>
<span class="sd">        The point where the ray will go through</span>
<span class="sd">    line: line Required</span>
<span class="sd">        The line which the ray is perpendicular to</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    line</span>
<span class="sd">        A ray that is perpendicular to the line</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">isPtOnLine</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">line</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ZeroVectorError</span><span class="p">()</span>

    <span class="c1"># Heading of line</span>
    <span class="n">heading</span> <span class="o">=</span> <span class="n">headingXY</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">heading</span> <span class="o">+=</span> <span class="mi">90</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">heading</span> <span class="o">&gt;</span> <span class="mi">360</span><span class="p">):</span>
        <span class="n">heading</span> <span class="o">-=</span> <span class="mi">360</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">heading</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">heading</span> <span class="o">+=</span> <span class="mi">360</span>

    <span class="c1"># Perp line    </span>
    <span class="n">perp</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="p">,</span> <span class="n">ptInDistXY</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">heading</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
    <span class="n">intPt</span> <span class="o">=</span> <span class="n">intLine2Line</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">perp</span><span class="p">)</span>
    <span class="n">ray</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="p">,</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">ray</span></div>


<div class="viewcode-block" id="ptFoot2Line">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.ptFoot2Line">[docs]</a>
<span class="k">def</span> <span class="nf">ptFoot2Line</span><span class="p">(</span><span class="n">pt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pt</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a point and a line, return the foot of that point on the line</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt: pt, required</span>
<span class="sd">        The point where the foot will go through</span>
<span class="sd">    line: line Required</span>
<span class="sd">        The line which the foot is perpendicular to</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    pt</span>
<span class="sd">        The foot of that point on the line</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isPtOnLine</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">line</span><span class="p">)):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ray</span> <span class="o">=</span> <span class="n">rayPerp2Line</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>


<span class="c1"># Line-shape intersection =====================================================</span>
<div class="viewcode-block" id="intLine2Line">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.intLine2Line">[docs]</a>
<span class="k">def</span> <span class="nf">intLine2Line</span><span class="p">(</span><span class="n">line1</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">line2</span><span class="p">:</span> <span class="n">line</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The intersection of a line to another line</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line1: line, required</span>
<span class="sd">        The first line</span>
<span class="sd">    line2: line, required</span>
<span class="sd">        The second line</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;status&#39;: &#39;Cross&#39;, # Relations between two objects,</span>
<span class="sd">        ...     &#39;intersect&#39;: pt, # The intersection,</span>
<span class="sd">        ...     &#39;intersectType&#39;: &#39;Point&#39;, # Type of intersection</span>
<span class="sd">        ...     &#39;interiorFlag&#39;: False, # True if the intersection is at the boundary</span>
<span class="sd">        ... }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">line1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line1</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
        <span class="k">raise</span> <span class="n">ZeroVectorError</span><span class="p">(</span><span class="n">line1</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">line2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line2</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
        <span class="k">raise</span> <span class="n">ZeroVectorError</span><span class="p">(</span><span class="n">line2</span><span class="p">)</span>

    <span class="c1"># Get Ax + By + C = 0</span>
    <span class="k">def</span> <span class="nf">abc</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">):</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">pt1</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">pt2</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">*</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">x2</span> <span class="o">*</span> <span class="n">y1</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>

    <span class="c1"># Calculate intersection</span>
    <span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">abc</span><span class="p">(</span><span class="n">line1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">abc</span><span class="p">(</span><span class="n">line2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">a2</span> <span class="o">*</span> <span class="n">b1</span>

    <span class="c1"># Check if parallel</span>
    <span class="c1"># 共线情形</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">D</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">is3PtsClockWise</span><span class="p">(</span><span class="n">line1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">line2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">line1</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Line&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">}</span>
    <span class="c1"># 平行情形</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">D</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
    <span class="c1"># 相交情形</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">b1</span> <span class="o">*</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">b2</span> <span class="o">*</span> <span class="n">c1</span><span class="p">)</span> <span class="o">/</span> <span class="n">D</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">a2</span> <span class="o">*</span> <span class="n">c1</span> <span class="o">-</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">c2</span><span class="p">)</span> <span class="o">/</span> <span class="n">D</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="intLine2Seg">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.intLine2Seg">[docs]</a>
<span class="k">def</span> <span class="nf">intLine2Seg</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">seg</span><span class="p">:</span> <span class="n">line</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The intersection of a line to another line segment</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line: line, required</span>
<span class="sd">        The first line</span>
<span class="sd">    seg: line, required</span>
<span class="sd">        The second line segment</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;status&#39;: &#39;Cross&#39;, # Relations between two objects,</span>
<span class="sd">        ...     &#39;intersect&#39;: pt, # The intersection,</span>
<span class="sd">        ...     &#39;intersectType&#39;: &#39;Point&#39;, # Type of intersection</span>
<span class="sd">        ...     &#39;interiorFlag&#39;: False, # True if the intersection is at the boundary</span>
<span class="sd">        ... }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">intPt</span> <span class="o">=</span> <span class="n">intLine2Line</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">seg</span><span class="p">)</span>

    <span class="c1"># 如果直线不相交，返回不相交</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">}</span>
    <span class="c1"># 如果直线和线段共线，返回线段</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">seg</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">}</span>
    <span class="c1"># 若相交点不在线段上，返回不相交</span>
    <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">isPtOnSeg</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">seg</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
    <span class="c1"># 若相交点在线段端点上，返回相交且不在interior</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="n">is2PtsSame</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
        <span class="p">}</span>
    <span class="c1"># 若相交点在线段内，返回相交且在interior内</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="intLine2Ray">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.intLine2Ray">[docs]</a>
<span class="k">def</span> <span class="nf">intLine2Ray</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">ray</span><span class="p">:</span> <span class="n">line</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The intersection of a line to a ray</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line: line, required</span>
<span class="sd">        The first line</span>
<span class="sd">    ray: line, required</span>
<span class="sd">        The second ray</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;status&#39;: &#39;Cross&#39;, # Relations between two objects,</span>
<span class="sd">        ...     &#39;intersect&#39;: pt, # The intersection,</span>
<span class="sd">        ...     &#39;intersectType&#39;: &#39;Point&#39;, # Type of intersection</span>
<span class="sd">        ...     &#39;interiorFlag&#39;: False, # True if the intersection is at the boundary</span>
<span class="sd">        ... }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">intPt</span> <span class="o">=</span> <span class="n">intLine2Line</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">ray</span><span class="p">)</span>

    <span class="c1"># 若直线不相交，返回不相交</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
    <span class="c1"># 若直线与射线共线，返回射线</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">intPt</span> <span class="o">==</span> <span class="s2">&quot;Collinear&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">ray</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Ray&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">}</span>
    <span class="c1"># 若相交点不在射线内，返回不相交</span>
    <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">isPtOnRay</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">ray</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
    <span class="c1"># 若相交点在射线端点上，返回相交且不在interior</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
        <span class="p">}</span>
    <span class="c1"># 若相交点在射线内，返回相交且在interior内</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">}</span>        </div>


<div class="viewcode-block" id="intSeg2Line">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.intSeg2Line">[docs]</a>
<span class="k">def</span> <span class="nf">intSeg2Line</span><span class="p">(</span><span class="n">seg</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The intersection of a line segment to another line</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seg: line, required</span>
<span class="sd">        The first line segment</span>
<span class="sd">    line: line, required</span>
<span class="sd">        The second line</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;status&#39;: &#39;Cross&#39;, # Relations between two objects,</span>
<span class="sd">        ...     &#39;intersect&#39;: pt, # The intersection,</span>
<span class="sd">        ...     &#39;intersectType&#39;: &#39;Point&#39;, # Type of intersection</span>
<span class="sd">        ...     &#39;interiorFlag&#39;: False, # True if the intersection is at the boundary</span>
<span class="sd">        ... }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">intLine2Seg</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">seg</span><span class="p">)</span></div>


<div class="viewcode-block" id="intSeg2Seg">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.intSeg2Seg">[docs]</a>
<span class="k">def</span> <span class="nf">intSeg2Seg</span><span class="p">(</span><span class="n">seg1</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">seg2</span><span class="p">:</span> <span class="n">line</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The intersection of a line segment to another line segment</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seg1: line, required</span>
<span class="sd">        The first line segment</span>
<span class="sd">    seg2: line, required</span>
<span class="sd">        The second line segment</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;status&#39;: &#39;Cross&#39;, # Relations between two objects,</span>
<span class="sd">        ...     &#39;intersect&#39;: pt, # The intersection,</span>
<span class="sd">        ...     &#39;intersectType&#39;: &#39;Point&#39;, # Type of intersection</span>
<span class="sd">        ...     &#39;interiorFlag&#39;: False, # True if the intersection is at the boundary</span>
<span class="sd">        ... }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">intPt</span> <span class="o">=</span> <span class="n">intLine2Line</span><span class="p">(</span><span class="n">seg1</span><span class="p">,</span> <span class="n">seg2</span><span class="p">)</span>

    <span class="c1"># 若直线不相交，返回不相交</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
    <span class="c1"># 若直线共线，进一步分情况讨论</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Collinear&quot;</span><span class="p">):</span>
        <span class="c1"># 线段端点是否在另一条线段上</span>
        <span class="n">seg1aInSeg2Flag</span> <span class="o">=</span> <span class="n">isPtOnSeg</span><span class="p">(</span><span class="n">seg1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg2</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">seg1bInSeg2Flag</span> <span class="o">=</span> <span class="n">isPtOnSeg</span><span class="p">(</span><span class="n">seg1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">seg2</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">seg2aInSeg1Flag</span> <span class="o">=</span> <span class="n">isPtOnSeg</span><span class="p">(</span><span class="n">seg2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg1</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">seg2bInSeg1Flag</span> <span class="o">=</span> <span class="n">isPtOnSeg</span><span class="p">(</span><span class="n">seg2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">seg1</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Case 1: seg1完全在seg2内</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">seg1aInSeg2Flag</span> <span class="ow">and</span> <span class="n">seg1bInSeg2Flag</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">seg1</span><span class="p">,</span>
                <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
                <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
            <span class="p">}</span>
        <span class="c1"># Case 2: seg2完全在seg1内</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">seg2aInSeg1Flag</span> <span class="ow">and</span> <span class="n">seg2bInSeg1Flag</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">seg2</span><span class="p">,</span>
                <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
                <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
            <span class="p">}</span>
        <span class="c1"># Case 3: seg1b在seg2内，seg2a在seg1内</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">seg1bInSeg2Flag</span> <span class="ow">and</span> <span class="n">seg2aInSeg1Flag</span><span class="p">):</span>
            <span class="c1"># Case 3.1: 相交在端点上</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">seg1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">seg2</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">seg1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
                <span class="p">}</span>
            <span class="c1"># Case 3.2: 有重合线段</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">seg1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">seg2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
                <span class="p">}</span>
        <span class="c1"># Case 4: seg1a在seg2内，seg2a在seg1内</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">seg1aInSeg2Flag</span> <span class="ow">and</span> <span class="n">seg2aInSeg1Flag</span><span class="p">):</span>
            <span class="c1"># Case 4.1: 相交在端点上</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">seg1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg2</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">seg1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
                <span class="p">}</span>
            <span class="c1"># Case 4.2: 有重合线段</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">seg1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
                <span class="p">}</span>
        <span class="c1"># Case 5: seg1b在seg2内，seg2b在seg1内</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">seg1bInSeg2Flag</span> <span class="ow">and</span> <span class="n">seg2bInSeg1Flag</span><span class="p">):</span>
            <span class="c1"># Case 5.1: 相交在端点上</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">seg1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">seg2</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">seg1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
                <span class="p">}</span>
            <span class="c1"># Case 5.2: 有重合线段</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">seg1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">seg2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
                <span class="p">}</span>
        <span class="c1"># Case 6: seg1a在seg2内，seg2b在seg1内</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">seg1aInSeg2Flag</span> <span class="ow">and</span> <span class="n">seg2bInSeg1Flag</span><span class="p">):</span>
            <span class="c1"># Case 6.1: 相交在端点上</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">seg1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg2</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">seg1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
                <span class="p">}</span>
            <span class="c1"># Case 6.2: 有重合线段</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">seg1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
                <span class="p">}</span>
        <span class="c1"># Case 7: 无相交</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
            <span class="p">}</span>
    <span class="c1"># 若交点不在任何一个线段上，不相交</span>
    <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">isPtOnSeg</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">seg1</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="n">isPtOnSeg</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">seg2</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
    <span class="c1"># 若交点在任意一个端点上，交于boundary</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">seg1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="ow">or</span> <span class="n">is2PtsSame</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">seg1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="ow">or</span> <span class="n">is2PtsSame</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">seg2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="ow">or</span> <span class="n">is2PtsSame</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">seg2</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
        <span class="p">}</span>
    <span class="c1"># 若交点在两个线段内，交于interior</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="intSeg2Ray">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.intSeg2Ray">[docs]</a>
<span class="k">def</span> <span class="nf">intSeg2Ray</span><span class="p">(</span><span class="n">seg</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">ray</span><span class="p">:</span> <span class="n">line</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The intersection of a line segment to a ray</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line: line, required</span>
<span class="sd">        The first line</span>
<span class="sd">    ray: line, required</span>
<span class="sd">        The second line</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;status&#39;: &#39;Cross&#39;, # Relations between two objects,</span>
<span class="sd">        ...     &#39;intersect&#39;: pt, # The intersection,</span>
<span class="sd">        ...     &#39;intersectType&#39;: &#39;Point&#39;, # Type of intersection</span>
<span class="sd">        ...     &#39;interiorFlag&#39;: False, # True if the intersection is at the boundary</span>
<span class="sd">        ... }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">intPt</span> <span class="o">=</span> <span class="n">intLine2Line</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">ray</span><span class="p">)</span>

    <span class="c1"># 若直线不相交，返回不相交</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
    <span class="c1"># 若直线共线，进一步分情况讨论</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Collinear&quot;</span><span class="p">):</span>
        <span class="c1"># 线段端点是否在射线内</span>
        <span class="n">segAInRayFlag</span> <span class="o">=</span> <span class="n">isPtOnRay</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ray</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">segBInRayFlag</span> <span class="o">=</span> <span class="n">isPtOnRay</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ray</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Case 1: seg整个在ray内</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">segAInRayFlag</span> <span class="ow">and</span> <span class="n">segBInRayFlag</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">seg</span><span class="p">,</span>
                <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
                <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
            <span class="p">}</span>
        <span class="c1"># Case 2: segA在ray内，segB不在ray内</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">segAInRayFlag</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">segBInRayFlag</span><span class="p">):</span>
            <span class="c1"># Case 2.1: 相交于射线的端点</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
                <span class="p">}</span>
            <span class="c1"># Case 2.2: 相较于射线内部</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
                <span class="p">}</span>
        <span class="c1"># Case 3: segB在ray内，segA不在ray内</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">segBInRayFlag</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">segAInRayFlag</span><span class="p">):</span>
            <span class="c1"># Case 3.1: 相交于射线的端点</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
                <span class="p">}</span>
            <span class="c1"># Case 3.2: 相较于射线内部</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
                <span class="p">}</span>
        <span class="c1"># Case 4: 无相交</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
            <span class="p">}</span>
    <span class="c1"># 若交点不在线段内或不在射线内，不相交</span>
    <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">isPtOnSeg</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">seg</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="n">isPtOnRay</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">ray</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
    <span class="c1"># 若交点在线段端点上或者在射线端点上，交于boundary</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="ow">or</span> <span class="n">is2PtsSame</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="ow">or</span> <span class="n">is2PtsSame</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
        <span class="p">}</span>
    <span class="c1"># 若交点在线段内且在射线内，交于interior</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="intRay2Line">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.intRay2Line">[docs]</a>
<span class="k">def</span> <span class="nf">intRay2Line</span><span class="p">(</span><span class="n">ray</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The intersection of a ray to another line</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ray: line, required</span>
<span class="sd">        The first line</span>
<span class="sd">    line: line, required</span>
<span class="sd">        The second line</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;status&#39;: &#39;Cross&#39;, # Relations between two objects,</span>
<span class="sd">        ...     &#39;intersect&#39;: pt, # The intersection,</span>
<span class="sd">        ...     &#39;intersectType&#39;: &#39;Point&#39;, # Type of intersection</span>
<span class="sd">        ...     &#39;interiorFlag&#39;: False, # True if the intersection is at the boundary</span>
<span class="sd">        ... }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">intLine2Ray</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">ray</span><span class="p">)</span></div>


<div class="viewcode-block" id="intRay2Seg">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.intRay2Seg">[docs]</a>
<span class="k">def</span> <span class="nf">intRay2Seg</span><span class="p">(</span><span class="n">ray</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">seg</span><span class="p">:</span> <span class="n">line</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The intersection of a ray to another line segment</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ray: line, required</span>
<span class="sd">        The first line</span>
<span class="sd">    seg: line, required</span>
<span class="sd">        The second line</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;status&#39;: &#39;Cross&#39;, # Relations between two objects,</span>
<span class="sd">        ...     &#39;intersect&#39;: pt, # The intersection,</span>
<span class="sd">        ...     &#39;intersectType&#39;: &#39;Point&#39;, # Type of intersection</span>
<span class="sd">        ...     &#39;interiorFlag&#39;: False, # True if the intersection is at the boundary</span>
<span class="sd">        ... }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">intSeg2Ray</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">ray</span><span class="p">)</span></div>


<div class="viewcode-block" id="intRay2Ray">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.intRay2Ray">[docs]</a>
<span class="k">def</span> <span class="nf">intRay2Ray</span><span class="p">(</span><span class="n">ray1</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">ray2</span><span class="p">:</span> <span class="n">line</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The intersection of a ray to another ray</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ray1: line, required</span>
<span class="sd">        The first line</span>
<span class="sd">    ray2: line, required</span>
<span class="sd">        The second line</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;status&#39;: &#39;Cross&#39;, # Relations between two objects,</span>
<span class="sd">        ...     &#39;intersect&#39;: pt, # The intersection,</span>
<span class="sd">        ...     &#39;intersectType&#39;: &#39;Point&#39;, # Type of intersection</span>
<span class="sd">        ...     &#39;interiorFlag&#39;: False, # True if the intersection is at the boundary</span>
<span class="sd">        ... }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">intPt</span> <span class="o">=</span> <span class="n">intLine2Line</span><span class="p">(</span><span class="n">ray1</span><span class="p">,</span> <span class="n">ray2</span><span class="p">)</span>

    <span class="c1"># 若直线不相交，返回不相交</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
    <span class="c1"># 若直线共线，进一步情况讨论</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Collinear&quot;</span><span class="p">):</span>
        <span class="c1"># 射线端点是否在其他射线内</span>
        <span class="n">ray1AInRay2Flag</span> <span class="o">=</span> <span class="n">isPtOnRay</span><span class="p">(</span><span class="n">ray1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ray2</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ray2AInRay1Flag</span> <span class="o">=</span> <span class="n">isPtOnRay</span><span class="p">(</span><span class="n">ray2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ray1</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Case 1: ray2a在ray1内，且ray1a在ray2内</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ray1AInRay2Flag</span> <span class="ow">and</span> <span class="n">ray2AInRay1Flag</span><span class="p">):</span>
            <span class="c1"># Case 1.1: 射线对头相交于端点</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">ray1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ray2</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">ray1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
                <span class="p">}</span>
            <span class="c1"># Case 1.2: 射线有重合线段</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">ray1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ray2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
                <span class="p">}</span>
        <span class="c1"># Case 2: ray2a在ray1内，且ray1a不在ray2内</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">ray2AInRay1Flag</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ray1AInRay2Flag</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">ray2</span><span class="p">,</span>
                <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Ray&#39;</span><span class="p">,</span>
                <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
            <span class="p">}</span>
        <span class="c1"># Case 3: ray1a在ray2内，且ray2a不在ray1内</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">ray1AInRay2Flag</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ray2AInRay1Flag</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">ray1</span><span class="p">,</span>
                <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Ray&#39;</span><span class="p">,</span>
                <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
            <span class="p">}</span>
        <span class="c1"># Case 4: 无相交</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Collinear&#39;</span><span class="p">,</span>
                <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
            <span class="p">}</span>
    <span class="c1"># 若直线相交点不在任何一个射线上，不相交</span>
    <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">isPtOnRay</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">ray1</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="n">isPtOnRay</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">ray2</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
    <span class="c1"># 若相交点在射线的端点上，交于boundary</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">ray1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="ow">or</span> <span class="n">is2PtsSame</span><span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span> <span class="n">ray2</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
        <span class="p">}</span>
    <span class="c1"># 若相交点在射线内，交于interior</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">],</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">}</span></div>


<span class="c1"># Line-shape versus Line-shape ===================================================</span>
<div class="viewcode-block" id="isLineIntLine">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isLineIntLine">[docs]</a>
<span class="k">def</span> <span class="nf">isLineIntLine</span><span class="p">(</span><span class="n">line1</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">line2</span><span class="p">:</span> <span class="n">line</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is two line intersect with each other?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line1: line, required</span>
<span class="sd">        The first line</span>
<span class="sd">    line2: line, required</span>
<span class="sd">        The second line</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if intersects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intPt</span> <span class="o">=</span> <span class="n">intLine2Line</span><span class="p">(</span><span class="n">line1</span><span class="p">,</span> <span class="n">line2</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="isLineIntSeg">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isLineIntSeg">[docs]</a>
<span class="k">def</span> <span class="nf">isLineIntSeg</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">seg</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a line intersect with a line segment?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line: line, required</span>
<span class="sd">        The first line</span>
<span class="sd">    seg: line, required</span>
<span class="sd">        The second line segment</span>
<span class="sd">    interiorOnly: bool, optional, default as False</span>
<span class="sd">        True if only consider intersecting in the interior</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if intersects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intPt</span> <span class="o">=</span> <span class="n">intLine2Seg</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">seg</span><span class="p">)</span>
    <span class="c1"># 无相交点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># 需要交于interior但未能交于interiror</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">interiorOnly</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;interiorFlag&#39;</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># 不需要交于interior或需要且交于interior</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="isLineIntRay">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isLineIntRay">[docs]</a>
<span class="k">def</span> <span class="nf">isLineIntRay</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">ray</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a line intersect with a ray?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line: line, required</span>
<span class="sd">        The first line</span>
<span class="sd">    ray: line, required</span>
<span class="sd">        The second ray</span>
<span class="sd">    interiorOnly: bool, optional, default as False</span>
<span class="sd">        True if only consider intersecting in the interior</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if intersects</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">intPt</span> <span class="o">=</span> <span class="n">intLine2Ray</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">ray</span><span class="p">)</span>
    <span class="c1"># 无相交点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># 需要交于interior但未能交于interiror</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">interiorOnly</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;interiorFlag&#39;</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># 不需要交于interior或需要且交于interior</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="isSegIntLine">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isSegIntLine">[docs]</a>
<span class="k">def</span> <span class="nf">isSegIntLine</span><span class="p">(</span><span class="n">seg</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a line segment intersect with a line?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seg: line, required</span>
<span class="sd">        The first line segment</span>
<span class="sd">    line: line, required</span>
<span class="sd">        The second line</span>
<span class="sd">    interiorOnly: bool, optional, default as False</span>
<span class="sd">        True if only consider intersecting in the interior</span>
<span class="sd">        </span>
<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if intersects</span>
<span class="sd">    &quot;&quot;&quot;</span>   
    <span class="k">return</span> <span class="n">isLineIntSeg</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">)</span></div>


<div class="viewcode-block" id="isSegIntSeg">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isSegIntSeg">[docs]</a>
<span class="k">def</span> <span class="nf">isSegIntSeg</span><span class="p">(</span><span class="n">seg1</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">seg2</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a line segment intersect with another line segment?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seg1: line, required</span>
<span class="sd">        The first line segment</span>
<span class="sd">    seg2: line, required</span>
<span class="sd">        The second line</span>
<span class="sd">    interiorOnly: bool, optional, default as False</span>
<span class="sd">        True if only consider intersecting in the interior</span>
<span class="sd">        </span>
<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if intersects</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">intPt</span> <span class="o">=</span> <span class="n">intSeg2Seg</span><span class="p">(</span><span class="n">seg1</span><span class="p">,</span> <span class="n">seg2</span><span class="p">)</span>
    <span class="c1"># 无相交点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># 需要交于interior但未能交于interiror</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">interiorOnly</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;interiorFlag&#39;</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># 不需要交于interior或需要且交于interior</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="isSegIntRay">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isSegIntRay">[docs]</a>
<span class="k">def</span> <span class="nf">isSegIntRay</span><span class="p">(</span><span class="n">seg</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">ray</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a line segment intersect with a ray?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seg: line, required</span>
<span class="sd">        The first line segment</span>
<span class="sd">    ray: line, required</span>
<span class="sd">        The second line</span>
<span class="sd">    interiorOnly: bool, optional, default as False</span>
<span class="sd">        True if only consider intersecting in the interior</span>
<span class="sd">        </span>
<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if intersects</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">intPt</span> <span class="o">=</span> <span class="n">intSeg2Ray</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">ray</span><span class="p">)</span>
    <span class="c1"># 无相交点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># 需要交于interior但未能交于interiror</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">interiorOnly</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;interiorFlag&#39;</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># 不需要交于interior或需要且交于interior</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="isSegIntBoundingbox">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isSegIntBoundingbox">[docs]</a>
<span class="k">def</span> <span class="nf">isSegIntBoundingbox</span><span class="p">(</span><span class="n">seg</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">boundingBox</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a line segment intersect with a given bounding box?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seg: line, required</span>
<span class="sd">        The first line segment</span>
<span class="sd">    boundingBox: list, required</span>
<span class="sd">        A list, in the following format: [minX, maxX, minY, maxY]</span>
<span class="sd">        </span>
<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if intersects</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># If both end is in the same side of bounding box</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="ow">and</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Clockwise check</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">is3PtsClockWise</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="n">is3PtsClockWise</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">boundingBox</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">!=</span> <span class="n">c2</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="n">c3</span> <span class="o">=</span> <span class="n">is3PtsClockWise</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">!=</span> <span class="n">c3</span> <span class="ow">or</span> <span class="n">c2</span> <span class="o">!=</span> <span class="n">c3</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="n">c4</span> <span class="o">=</span> <span class="n">is3PtsClockWise</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">boundingBox</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">!=</span> <span class="n">c4</span> <span class="ow">or</span> <span class="n">c2</span> <span class="o">!=</span> <span class="n">c4</span> <span class="ow">or</span> <span class="n">c3</span> <span class="o">!=</span> <span class="n">c4</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="isRayIntLine">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isRayIntLine">[docs]</a>
<span class="k">def</span> <span class="nf">isRayIntLine</span><span class="p">(</span><span class="n">ray</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a ray intersect with a line?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ray: line, required</span>
<span class="sd">        The first line segment</span>
<span class="sd">    line: line, required</span>
<span class="sd">        The second line</span>
<span class="sd">    interiorOnly: bool, optional, default as False</span>
<span class="sd">        True if only consider intersecting in the interior</span>
<span class="sd">        </span>
<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if intersects</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="k">return</span> <span class="n">isLineIntRay</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">ray</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">)</span></div>


<div class="viewcode-block" id="isRayIntSeg">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isRayIntSeg">[docs]</a>
<span class="k">def</span> <span class="nf">isRayIntSeg</span><span class="p">(</span><span class="n">ray</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">seg</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a ray intersect with a line segment?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ray: line, required</span>
<span class="sd">        The first line segment</span>
<span class="sd">    seg: line, required</span>
<span class="sd">        The second line</span>
<span class="sd">    interiorOnly: bool, optional, default as False</span>
<span class="sd">        True if only consider intersecting in the interior</span>
<span class="sd">        </span>
<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if intersects</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="k">return</span> <span class="n">isSegIntRay</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">ray</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">)</span></div>


<div class="viewcode-block" id="isRayIntRay">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isRayIntRay">[docs]</a>
<span class="k">def</span> <span class="nf">isRayIntRay</span><span class="p">(</span><span class="n">ray1</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">ray2</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a ray intersect with a ray?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ray1: line, required</span>
<span class="sd">        The first line segment</span>
<span class="sd">    ray2: line, required</span>
<span class="sd">        The second line</span>
<span class="sd">    interiorOnly: bool, optional, default as False</span>
<span class="sd">        True if only consider intersecting in the interior</span>
<span class="sd">        </span>
<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if intersects</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">intPt</span> <span class="o">=</span> <span class="n">intRay2Ray</span><span class="p">(</span><span class="n">ray1</span><span class="p">,</span> <span class="n">ray2</span><span class="p">)</span>
    <span class="c1"># 无相交点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># 需要交于interior但未能交于interiror</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">interiorOnly</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;interiorFlag&#39;</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># 不需要交于interior或需要且交于interior</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<span class="c1"># Line-shape intersect with polygon ===========================================</span>
<div class="viewcode-block" id="intLine2Poly">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.intLine2Poly">[docs]</a>
<span class="k">def</span> <span class="nf">intLine2Poly</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">poly</span><span class="p">:</span> <span class="n">poly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">returnShaplelyObj</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">|</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Point</span> <span class="o">|</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span> <span class="o">|</span> <span class="n">shapely</span><span class="o">.</span><span class="n">GeometryCollection</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The intersection of a line to a polygon</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line: line, required</span>
<span class="sd">        The first line</span>
<span class="sd">    poly: poly, optional, default as None</span>
<span class="sd">        The second polygon</span>
<span class="sd">    polyShapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely object for polygon. Need to provide one of the following fields: [`poly`, `polyShapely`]</span>
<span class="sd">    returnShaplelyObj: bool, optional, default as False</span>
<span class="sd">        True if alter the result to be a shapely object        </span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;status&#39;: &#39;Cross&#39;, # Relations between two objects,</span>
<span class="sd">        ...     &#39;intersect&#39;: pt, # The intersection,</span>
<span class="sd">        ...     &#39;intersectType&#39;: &#39;Point&#39;, # Type of intersection</span>
<span class="sd">        ...     &#39;interiorFlag&#39;: False, # True if the intersection is at the boundary</span>
<span class="sd">        ... }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sanity check</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">poly</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">polyShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: `poly` and `polyShapely` cannot be None at the same time.&quot;</span><span class="p">)</span>

    <span class="c1"># Projct points to the line</span>
    <span class="n">projPts</span> <span class="o">=</span> <span class="p">[]</span>    
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">:</span>
        <span class="n">projPts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ptFoot2Line</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>

    <span class="c1"># Find two pts on the line that are the farthest away from each other =====</span>
    <span class="n">projPts</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">seg</span> <span class="o">=</span> <span class="p">[</span><span class="n">projPts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">projPts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">intSeg2Poly</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">,</span> <span class="n">returnShaplelyObj</span><span class="p">)</span></div>


<div class="viewcode-block" id="intSeg2Poly">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.intSeg2Poly">[docs]</a>
<span class="k">def</span> <span class="nf">intSeg2Poly</span><span class="p">(</span><span class="n">seg</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">poly</span><span class="p">:</span> <span class="n">poly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">returnShaplelyObj</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">|</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Point</span> <span class="o">|</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span> <span class="o">|</span> <span class="n">shapely</span><span class="o">.</span><span class="n">GeometryCollection</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The intersection of a line segment to a polygon</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seg: line, required</span>
<span class="sd">        The first line segment</span>
<span class="sd">    poly: poly, optional, default as None</span>
<span class="sd">        The second polygon</span>
<span class="sd">    polyShapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely object for polygon. Need to provide one of the following fields: [`poly`, `polyShapely`]</span>
<span class="sd">    returnShaplelyObj: bool, optional, default as False</span>
<span class="sd">        True if alter the result to be a shapely object        </span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;status&#39;: &#39;Cross&#39;, # Relations between two objects,</span>
<span class="sd">        ...     &#39;intersect&#39;: pt, # The intersection,</span>
<span class="sd">        ...     &#39;intersectType&#39;: &#39;Point&#39;, # Type of intersection</span>
<span class="sd">        ...     &#39;interiorFlag&#39;: False, # True if the intersection is at the boundary</span>
<span class="sd">        ... }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># WARNING: Results may not be reliable on both ends of the seg.</span>
    <span class="c1"># NOTE: 20231103 暂时用了一个stupid way来处理了</span>

    <span class="c1"># Sanity check ============================================================</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">poly</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">polyShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: `poly` and `polyShapely` cannot be None at the same time.&quot;</span><span class="p">)</span>

    <span class="c1"># get shapely objects =====================================================</span>
    <span class="n">segShapely</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">LineString</span><span class="p">([</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">polyShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">polyShapely</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
    <span class="n">intShape</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">segShapely</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">)</span>

    <span class="c1"># If return shapely objects no processing needed ==========================</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">returnShaplelyObj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">intShape</span>

    <span class="c1"># 若不相交，返回不相交</span>
    <span class="c1"># FIXME: 现在的精度可能有问题，需要计算两者间距离</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intShape</span><span class="o">.</span><span class="n">is_empty</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">segShapely</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">CONST_EPSILON</span><span class="p">):</span>
            <span class="c1"># Case 1: 若两个端点足够近</span>
            <span class="n">end1Dist</span> <span class="o">=</span> <span class="n">distPt2Poly</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">polyShapely</span> <span class="o">=</span> <span class="n">polyShapely</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">end1Dist</span> <span class="o">&lt;=</span> <span class="n">CONST_EPSILON</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
                <span class="p">}</span>
            <span class="n">end2Dist</span> <span class="o">=</span> <span class="n">distPt2Poly</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">polyShapely</span> <span class="o">=</span> <span class="n">polyShapely</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">end2Dist</span> <span class="o">&lt;=</span> <span class="n">CONST_EPSILON</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
                <span class="p">}</span>
            <span class="c1"># Case 2: 相切的情形</span>
            <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
                <span class="n">ptDist</span> <span class="o">=</span> <span class="n">distPt2Seg</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">seg</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ptDist</span> <span class="o">&lt;=</span> <span class="n">CONST_EPSILON</span><span class="p">):</span>
                    <span class="k">return</span> <span class="p">{</span>
                        <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span>
                        <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
                    <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">,</span>
                <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
            <span class="p">}</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">intShape</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Point</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">intShape</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">intShape</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
        <span class="p">}</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">intShape</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">LineString</span><span class="p">)):</span>
        <span class="n">seg</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">intShape</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">intShape</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">midPt</span> <span class="o">=</span> <span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                 <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">interiorFlag</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">polyShapely</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">midPt</span><span class="p">))</span>
        <span class="c1"># NOTE: 由于精度的问题，实际上是Point的情况可能会返回Segment</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">CONST_EPSILON</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
                <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="n">interiorFlag</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
                <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">seg</span><span class="p">,</span>
                <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
                <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="n">interiorFlag</span>
            <span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">intSp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">intShape</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Point</span><span class="p">)):</span>
                <span class="n">intSp</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
                <span class="p">})</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">LineString</span><span class="p">)):</span>
                <span class="n">seg</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="n">midPt</span> <span class="o">=</span> <span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                         <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">interiorFlag</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">polyShapely</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">midPt</span><span class="p">))</span>
                <span class="c1"># NOTE: 由于精度的问题，实际上是Point的情况可能会返回Segment</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">CONST_EPSILON</span><span class="p">):</span>
                    <span class="n">intSp</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="n">interiorFlag</span>
                    <span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">intSp</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">seg</span><span class="p">,</span>
                        <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="n">interiorFlag</span>
                    <span class="p">})</span>
        <span class="k">return</span> <span class="n">intSp</span></div>


<div class="viewcode-block" id="intRay2Poly">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.intRay2Poly">[docs]</a>
<span class="k">def</span> <span class="nf">intRay2Poly</span><span class="p">(</span><span class="n">ray</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">poly</span><span class="p">:</span> <span class="n">poly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">returnShaplelyObj</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">|</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Point</span> <span class="o">|</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span> <span class="o">|</span> <span class="n">shapely</span><span class="o">.</span><span class="n">GeometryCollection</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The intersection of a ray to a polygon</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ray: line, required</span>
<span class="sd">        The first ray</span>
<span class="sd">    poly: poly, optional, default as None</span>
<span class="sd">        The second polygon</span>
<span class="sd">    polyShapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely object for polygon. Need to provide one of the following fields: [`poly`, `polyShapely`]</span>
<span class="sd">    returnShaplelyObj: bool, optional, default as False</span>
<span class="sd">        True if alter the result to be a shapely object        </span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;status&#39;: &#39;Cross&#39;, # Relations between two objects,</span>
<span class="sd">        ...     &#39;intersect&#39;: pt, # The intersection,</span>
<span class="sd">        ...     &#39;intersectType&#39;: &#39;Point&#39;, # Type of intersection</span>
<span class="sd">        ...     &#39;interiorFlag&#39;: False, # True if the intersection is at the boundary</span>
<span class="sd">        ... }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sanity check</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">poly</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">polyShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: `poly` and `polyShapely` cannot be None at the same time.&quot;</span><span class="p">)</span>

    <span class="c1"># Project points to the line</span>
    <span class="n">projPts</span> <span class="o">=</span> <span class="p">[]</span>    
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">:</span>
        <span class="n">projPts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ptFoot2Line</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">ray</span><span class="p">))</span>

    <span class="n">projPts</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">minPt</span> <span class="o">=</span> <span class="n">projPts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">maxPt</span> <span class="o">=</span> <span class="n">projPts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="n">isMinPtOnRay</span> <span class="o">=</span> <span class="n">isPtOnRay</span><span class="p">(</span><span class="n">minPt</span><span class="p">,</span> <span class="n">ray</span><span class="p">)</span>
    <span class="n">isMaxPtOnRay</span> <span class="o">=</span> <span class="n">isPtOnRay</span><span class="p">(</span><span class="n">maxPt</span><span class="p">,</span> <span class="n">ray</span><span class="p">)</span>
    <span class="c1"># 若minPt和maxPt均不能投影到射线上，肯定不相交</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">isMinPtOnRay</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isMaxPtOnRay</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
    <span class="c1"># 若两个都在射线上，射线可能的与之相交部分在两点间</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">isMinPtOnRay</span> <span class="ow">and</span> <span class="n">isMaxPtOnRay</span><span class="p">):</span>
        <span class="n">seg</span> <span class="o">=</span> <span class="p">[</span><span class="n">minPt</span><span class="p">,</span> <span class="n">maxPt</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">intSeg2Poly</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">,</span> <span class="n">returnShaplelyObj</span><span class="p">)</span>
    <span class="c1"># 若minPt在射线上，maxPt不在</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">isMinPtOnRay</span><span class="p">):</span>
        <span class="n">seg</span> <span class="o">=</span> <span class="p">[</span><span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">minPt</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">intSeg2Poly</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">,</span> <span class="n">returnShaplelyObj</span><span class="p">)</span>
    <span class="c1"># 若maxPt在射线上，minPt不在</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">seg</span> <span class="o">=</span> <span class="p">[</span><span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">maxPt</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">intSeg2Poly</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">,</span> <span class="n">returnShaplelyObj</span><span class="p">)</span></div>


<div class="viewcode-block" id="intSeq2Poly">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.intSeq2Poly">[docs]</a>
<span class="k">def</span> <span class="nf">intSeq2Poly</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span> <span class="n">poly</span><span class="p">:</span> <span class="n">poly</span><span class="p">,</span> <span class="n">seqShapely</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">LineString</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">returnShaplelyObj</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The intersection of a sequence to a polygon</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seq: list of pt, required</span>
<span class="sd">        The first sequence of points</span>
<span class="sd">    poly: poly, optional, default as None</span>
<span class="sd">        The second polygon</span>
<span class="sd">    polyShapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely object for polygon. Need to provide one of the following fields: [`poly`, `polyShapely`]</span>
<span class="sd">    returnShaplelyObj: bool, optional, default as False</span>
<span class="sd">        True if alter the result to be a shapely object        </span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;status&#39;: &#39;Cross&#39;, # Relations between two objects,</span>
<span class="sd">        ...     &#39;intersect&#39;: pt, # The intersection,</span>
<span class="sd">        ...     &#39;intersectType&#39;: &#39;Point&#39;, # Type of intersection</span>
<span class="sd">        ...     &#39;interiorFlag&#39;: False, # True if the intersection is at the boundary</span>
<span class="sd">        ... }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sanity check</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">seq</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">seqShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: `seq` and `seqShapely` cannot be None at the same time.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">poly</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">polyShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: `poly` and `polyShapely` cannot be None at the same time.&quot;</span><span class="p">)</span>

    <span class="c1"># get shapely objects</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">seqShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">seqShapely</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">LineString</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">polyShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">polyShapely</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
    <span class="n">intShape</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">seqShapely</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">)</span>

    <span class="c1"># If return shapely objects no processing needed</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">returnShaplelyObj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">intShape</span> 
    <span class="c1"># 若不相交，返回不相交</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intShape</span><span class="o">.</span><span class="n">is_empty</span><span class="p">):</span>
        <span class="c1"># FIXME: 误差的部分之后加，现在只考虑用在clipRoadNetworkByPoly()里</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">intShape</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Point</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">intShape</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">intShape</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
        <span class="p">}</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">intShape</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">LineString</span><span class="p">)):</span>
        <span class="n">intSeq</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">intShape</span><span class="o">.</span><span class="n">coords</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">intSeq</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">intSp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">intShape</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Point</span><span class="p">)):</span>
                <span class="n">intSp</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
                <span class="p">})</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">LineString</span><span class="p">)):</span>
                <span class="n">intSeq</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">coords</span><span class="p">]</span>
                <span class="n">intSp</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">intSeq</span><span class="p">,</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
                <span class="p">})</span>
        <span class="k">return</span> <span class="n">intSp</span></div>


<span class="c1"># Line-shape versus polygon ===================================================</span>
<div class="viewcode-block" id="isLineIntPoly">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isLineIntPoly">[docs]</a>
<span class="k">def</span> <span class="nf">isLineIntPoly</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">poly</span><span class="p">:</span> <span class="n">poly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a line intersects to a polygon?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line: line, required</span>
<span class="sd">        The first line</span>
<span class="sd">    poly: poly, optional, default as None</span>
<span class="sd">        The second polygon</span>
<span class="sd">    polyShapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely object for polygon. Need to provide one of the following fields: [`poly`, `polyShapely`]</span>
<span class="sd">    returnShaplelyObj: bool, optional, default as False</span>
<span class="sd">        True if alter the result to be a shapely object        </span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if intersects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intSp</span> <span class="o">=</span> <span class="n">intLine2Poly</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">)</span>
    <span class="c1"># 若只输出了一个字典，按字典判断</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">intSp</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">intSp</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Cross&#39;</span> 
            <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">interiorOnly</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">intSp</span><span class="p">[</span><span class="s1">&#39;interiorFlag&#39;</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">intSp</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">intPt</span> <span class="ow">in</span> <span class="n">intSp</span><span class="p">:</span>
            <span class="n">trueWhen</span> <span class="o">=</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Cross&#39;</span> 
                <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">interiorOnly</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;interiorFlag&#39;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">trueWhen</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>    
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="isSegIntPoly">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isSegIntPoly">[docs]</a>
<span class="k">def</span> <span class="nf">isSegIntPoly</span><span class="p">(</span><span class="n">seg</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">poly</span><span class="p">:</span> <span class="n">poly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a line segment intersects to a polygon?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seg: line, required</span>
<span class="sd">        The first line</span>
<span class="sd">    poly: poly, optional, default as None</span>
<span class="sd">        The second polygon</span>
<span class="sd">    polyShapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely object for polygon. Need to provide one of the following fields: [`poly`, `polyShapely`]</span>
<span class="sd">    returnShaplelyObj: bool, optional, default as False</span>
<span class="sd">        True if alter the result to be a shapely object        </span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if intersects</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># WARNING: results may not be reliable if `interiorFlag` == False.</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Is a segment intersect with a polygon&quot;&quot;&quot;</span>
    <span class="n">intSp</span> <span class="o">=</span> <span class="n">intSeg2Poly</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">)</span>
    <span class="c1"># 若只输出了一个字典，按字典判断</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">intSp</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">intSp</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Cross&#39;</span> 
            <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">interiorOnly</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">intSp</span><span class="p">[</span><span class="s1">&#39;interiorFlag&#39;</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">intSp</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">intPt</span> <span class="ow">in</span> <span class="n">intSp</span><span class="p">:</span>
            <span class="n">trueWhen</span> <span class="o">=</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Cross&#39;</span> 
                <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">interiorOnly</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;interiorFlag&#39;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">trueWhen</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>    
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="isRayIntPoly">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isRayIntPoly">[docs]</a>
<span class="k">def</span> <span class="nf">isRayIntPoly</span><span class="p">(</span><span class="n">ray</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">poly</span><span class="p">:</span> <span class="n">poly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a ray intersects to a polygon?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ray: line, required</span>
<span class="sd">        The first line</span>
<span class="sd">    poly: poly, optional, default as None</span>
<span class="sd">        The second polygon</span>
<span class="sd">    polyShapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely object for polygon. Need to provide one of the following fields: [`poly`, `polyShapely`]</span>
<span class="sd">    returnShaplelyObj: bool, optional, default as False</span>
<span class="sd">        True if alter the result to be a shapely object        </span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    bool</span>
<span class="sd">        True if intersects</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">intSp</span> <span class="o">=</span> <span class="n">intRay2Poly</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">)</span>
    <span class="c1"># 若只输出了一个字典，按字典判断</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">intSp</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">intSp</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Cross&#39;</span> 
            <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">interiorOnly</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">intSp</span><span class="p">[</span><span class="s1">&#39;interiorFlag&#39;</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">intSp</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">intPt</span> <span class="ow">in</span> <span class="n">intSp</span><span class="p">:</span>
            <span class="n">trueWhen</span> <span class="o">=</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Cross&#39;</span> 
                <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">interiorOnly</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;interiorFlag&#39;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">trueWhen</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>    
        <span class="k">return</span> <span class="kc">False</span></div>


<span class="c1"># Poly vs poly ================================================================</span>
<div class="viewcode-block" id="intPoly2Poly">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.intPoly2Poly">[docs]</a>
<span class="k">def</span> <span class="nf">intPoly2Poly</span><span class="p">(</span><span class="n">poly1</span><span class="p">:</span> <span class="n">poly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">poly2</span><span class="p">:</span> <span class="n">poly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">poly1Shapely</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">poly2Shapely</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Intersection between two polygons</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    poly1: poly, optional, default as None</span>
<span class="sd">        The first polygon</span>
<span class="sd">    poly2: poly, optional, default as None</span>
<span class="sd">        The second polygon</span>
<span class="sd">    poly1Shapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely object for the first polygon. Need to provide one of the following fields: [`poly1`, `poly1Shapely`]</span>
<span class="sd">    poly2Shapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely object for the second polygon. Need to provide one of the following fields: [`poly2`, `poly2Shapely`]</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;status&#39;: &#39;Cross&#39;, # Relations between two objects,</span>
<span class="sd">        ...     &#39;intersect&#39;: pt, # The intersection,</span>
<span class="sd">        ...     &#39;intersectType&#39;: &#39;Point&#39;, # Type of intersection</span>
<span class="sd">        ...     &#39;interiorFlag&#39;: False, # True if the intersection is at the boundary</span>
<span class="sd">        ... }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">poly1Shapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">poly1Shapely</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">poly1</span><span class="p">])</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">poly2Shapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">poly2Shapely</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">poly2</span><span class="p">])</span>

    <span class="n">intShape</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">poly1Shapely</span><span class="p">,</span> <span class="n">poly2Shapely</span><span class="p">)</span>
    <span class="n">intType</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">get_type_id</span><span class="p">(</span><span class="n">intShape</span><span class="p">)</span>

    <span class="c1"># Point</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intType</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">intShape</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">intShape</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
        <span class="p">}</span>
    <span class="c1"># LineString</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">intType</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">intShape</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">intShape</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
        <span class="p">}</span>
    <span class="c1"># Polygon</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">intType</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">intShape</span><span class="o">.</span><span class="n">is_empty</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">(</span><span class="n">intShape</span><span class="p">)[</span><span class="s1">&#39;coordinates&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Polygon&#39;</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">}</span>
    <span class="c1"># MultiPoint/MultiLineString/MultiPolygon/GeometryCollection</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">intType</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]):</span>
        <span class="n">intSp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">intShape</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
            <span class="n">intG</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">get_type_id</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="c1"># Point</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">intG</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">intSp</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
                <span class="p">})</span>
            <span class="c1"># LineString</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">intG</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">intSp</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">g</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Segment&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">False</span>
                <span class="p">})</span>
            <span class="c1"># Polygon</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">intG</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
                <span class="n">intSp</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">(</span><span class="n">g</span><span class="p">)[</span><span class="s1">&#39;coordinates&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="s1">&#39;Polygon&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">True</span>
                <span class="p">})</span>
        <span class="k">return</span> <span class="n">intSp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">,</span>
            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;intersectType&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;interiorFlag&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="isPolyIntPoly">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.isPolyIntPoly">[docs]</a>
<span class="k">def</span> <span class="nf">isPolyIntPoly</span><span class="p">(</span><span class="n">poly1</span><span class="p">:</span> <span class="n">poly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">poly2</span><span class="p">:</span> <span class="n">poly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">poly1Shapely</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">poly2Shapely</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is a polygon intersect to another polygon</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    poly1: poly, optional, default as None</span>
<span class="sd">        The first polygon</span>
<span class="sd">    poly2: poly, optional, default as None</span>
<span class="sd">        The second polygon</span>
<span class="sd">    poly1Shapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely object for the first polygon. Need to provide one of the following fields: [`poly1`, `poly1Shapely`]</span>
<span class="sd">    poly2Shapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely object for the second polygon. Need to provide one of the following fields: [`poly2`, `poly2Shapely`]</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;status&#39;: &#39;Cross&#39;, # Relations between two objects,</span>
<span class="sd">        ...     &#39;intersect&#39;: pt, # The intersection,</span>
<span class="sd">        ...     &#39;intersectType&#39;: &#39;Point&#39;, # Type of intersection</span>
<span class="sd">        ...     &#39;interiorFlag&#39;: False, # True if the intersection is at the boundary</span>
<span class="sd">        ... }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">intSp</span> <span class="o">=</span> <span class="n">intPoly2Poly</span><span class="p">(</span><span class="n">poly1</span><span class="p">,</span> <span class="n">poly2</span><span class="p">,</span> <span class="n">poly1Shapely</span><span class="p">,</span> <span class="n">poly2Shapely</span><span class="p">)</span>
    <span class="c1"># 若只输出了一个字典，按字典判断</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">intSp</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">intSp</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Cross&#39;</span> 
            <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">interiorOnly</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">intSp</span><span class="p">[</span><span class="s1">&#39;interiorFlag&#39;</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">intSp</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">intPt</span> <span class="ow">in</span> <span class="n">intSp</span><span class="p">:</span>
            <span class="n">trueWhen</span> <span class="o">=</span> <span class="p">(</span><span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Cross&#39;</span> 
                <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">interiorOnly</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">intPt</span><span class="p">[</span><span class="s1">&#39;interiorFlag&#39;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">trueWhen</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>    
        <span class="k">return</span> <span class="kc">False</span></div>


<span class="c1"># Distance from Point to Object ===============================================</span>
<div class="viewcode-block" id="distPt2Line">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.distPt2Line">[docs]</a>
<span class="k">def</span> <span class="nf">distPt2Line</span><span class="p">(</span><span class="n">pt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The distance between a point and a line</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt: pt, required</span>
<span class="sd">        The point</span>
<span class="sd">    line: line, required</span>
<span class="sd">        The line</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    float</span>
<span class="sd">        The distance between two objects</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">area</span> <span class="o">=</span> <span class="n">calTriangleAreaXY</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
    <span class="n">h</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">area</span> <span class="o">/</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">h</span></div>


<div class="viewcode-block" id="distPt2Seg">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.distPt2Seg">[docs]</a>
<span class="k">def</span> <span class="nf">distPt2Seg</span><span class="p">(</span><span class="n">pt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">seg</span><span class="p">:</span> <span class="n">line</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The distance between a point and a line segment</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt: pt, required</span>
<span class="sd">        The point</span>
<span class="sd">    seg: line, required</span>
<span class="sd">        The line segment</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    float</span>
<span class="sd">        The distance between two objects</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">foot</span> <span class="o">=</span> <span class="n">ptFoot2Line</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">seg</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isPtOnSeg</span><span class="p">(</span><span class="n">foot</span><span class="p">,</span> <span class="n">seg</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">foot</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">],</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">])</span></div>


<div class="viewcode-block" id="distPt2Ray">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.distPt2Ray">[docs]</a>
<span class="k">def</span> <span class="nf">distPt2Ray</span><span class="p">(</span><span class="n">pt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">ray</span><span class="p">:</span> <span class="n">line</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The distance between a point and a ray</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt: pt, required</span>
<span class="sd">        The point</span>
<span class="sd">    ray: line, required</span>
<span class="sd">        The ray</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    float</span>
<span class="sd">        The distance between two objects</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">foot</span> <span class="o">=</span> <span class="n">ptFoot2Line</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">ray</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isPtOnRay</span><span class="p">(</span><span class="n">foot</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">foot</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="distPt2Seq">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.distPt2Seq">[docs]</a>
<span class="k">def</span> <span class="nf">distPt2Seq</span><span class="p">(</span><span class="n">pt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">seq</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pt</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The distance between a point and a sequence of points</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt: pt, required</span>
<span class="sd">        The point</span>
<span class="sd">    seq: list of pt, required</span>
<span class="sd">        A sequence of points</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    float</span>
<span class="sd">        The distance between two objects</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># FIXME: stupid way, needs improvement</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">distPt2Seg</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>

    <span class="n">dist2Seg</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
        <span class="n">dist2Seg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    <span class="n">minIndex</span> <span class="o">=</span> <span class="n">dist2Seg</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">dist2Seg</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">minIndex</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">distPt2Seg</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">minIndex</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist2Seg</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">distPt2Seg</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">distPt2Seg</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="n">minIndex</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">minIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]),</span>
                   <span class="n">dist2Seg</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="n">minIndex</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">minIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]))</span></div>


<div class="viewcode-block" id="distPt2Poly">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.distPt2Poly">[docs]</a>
<span class="k">def</span> <span class="nf">distPt2Poly</span><span class="p">(</span><span class="n">pt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">poly</span><span class="p">:</span> <span class="n">poly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The distance between a point and a polygon</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt: pt, required</span>
<span class="sd">        The point</span>
<span class="sd">    poly: poly, optional, default as None</span>
<span class="sd">        The polygon</span>
<span class="sd">    polyShapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely object for polygon. Need to provide one of the following fields: [`poly`, `polyShapely`]</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    float</span>
<span class="sd">        The distance between two objects</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">poly</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">polyShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: Missing required field `poly` or `polyShapely`&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">polyShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">polyShapely</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">])</span>
    <span class="n">ptShapely</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">shapely</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">ptShapely</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">)</span></div>


<div class="viewcode-block" id="nearestPtLine2Poly">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.nearestPtLine2Poly">[docs]</a>
<span class="k">def</span> <span class="nf">nearestPtLine2Poly</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="n">poly</span><span class="p">:</span> <span class="n">poly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the nearest point between a line and a polygon</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line: line, required</span>
<span class="sd">        The line</span>
<span class="sd">    poly: poly, optional, default as None</span>
<span class="sd">        The polygon</span>
<span class="sd">    polyShapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely object for polygon. Need to provide one of the following fields: [`poly`, `polyShapely`]</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;ptOnLine&#39;: pt, # The point from the line,</span>
<span class="sd">        ...     &#39;ptOnPoly&#39;: pt, # The point from the polygon,</span>
<span class="sd">        ... }</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">poly</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">polyShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: Missing required field `poly` or `polyShapely`&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">polyShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">polyShapely</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">])</span>
    <span class="n">lineShapely</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">LineString</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="n">nearestPts</span> <span class="o">=</span> <span class="n">nearest_points</span><span class="p">(</span><span class="n">lineShapely</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;ptOnLine&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">nearestPts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">nearestPts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
        <span class="s1">&#39;ptOnPoly&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">nearestPts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">nearestPts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
    <span class="p">}</span></div>


<span class="c1"># Dimension mapping ===========================================================</span>
<div class="viewcode-block" id="vecPolar2XY">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.vecPolar2XY">[docs]</a>
<span class="k">def</span> <span class="nf">vecPolar2XY</span><span class="p">(</span><span class="n">vecPolar</span><span class="p">:</span> <span class="n">pt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pt</span><span class="p">:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given vector&#39;s norm and its degree to North, convert it into a 2-tuple vector</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vecPolar: tuple[float|int, float|int], required</span>
<span class="sd">        A 2-tuple (vVal, vDeg), `vVal` is the norm and `vDeg` is the direction, 0 as North, clockwise, in [0, 360)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[float|int, float|int]</span>
<span class="sd">        The XY vector</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Initialize ==============================================================</span>
    <span class="p">(</span><span class="n">vVal</span><span class="p">,</span> <span class="n">vDeg</span><span class="p">)</span> <span class="o">=</span> <span class="n">vecPolar</span>

    <span class="n">vX</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">vY</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span><span class="p">(</span><span class="n">vDeg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">vDeg</span> <span class="o">=</span> <span class="n">vDeg</span> <span class="o">+</span> <span class="mi">360</span>

    <span class="k">while</span><span class="p">(</span><span class="n">vDeg</span> <span class="o">&gt;=</span> <span class="mi">360</span><span class="p">):</span>
        <span class="n">vDeg</span> <span class="o">=</span> <span class="n">vDeg</span> <span class="o">-</span> <span class="mi">360</span>

    <span class="n">vX</span> <span class="o">=</span> <span class="n">vVal</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">vDeg</span><span class="p">))</span>
    <span class="n">vY</span> <span class="o">=</span> <span class="n">vVal</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">vDeg</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">vX</span><span class="p">,</span> <span class="n">vY</span><span class="p">)</span></div>


<div class="viewcode-block" id="vecXY2Polar">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.vecXY2Polar">[docs]</a>
<span class="k">def</span> <span class="nf">vecXY2Polar</span><span class="p">(</span><span class="n">vecXY</span><span class="p">:</span> <span class="n">pt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pt</span><span class="p">:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a 2-tuple, convert it into a norm and a direction in degree</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vecXY: tuple[float|int, float|int], required</span>
<span class="sd">        A 2-tuple (vX, vY), the coordinate of vector</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[float|int, float|int]</span>
<span class="sd">        The polar vector</span>
<span class="sd">    &quot;&quot;&quot;</span>    

    <span class="p">(</span><span class="n">vX</span><span class="p">,</span> <span class="n">vY</span><span class="p">)</span> <span class="o">=</span> <span class="n">vecXY</span>    
    <span class="n">vDeg</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">vVal</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">vX</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">CONST_EPSILON</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vY</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">vDeg</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">vVal</span> <span class="o">=</span> <span class="n">vY</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">vY</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">vDeg</span> <span class="o">=</span> <span class="mi">180</span>
            <span class="n">vVal</span> <span class="o">=</span> <span class="o">-</span><span class="n">vY</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">vY</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">CONST_EPSILON</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vX</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">vVal</span> <span class="o">=</span> <span class="n">vX</span>
            <span class="n">vDeg</span> <span class="o">=</span> <span class="mi">90</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">vX</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">vVal</span> <span class="o">=</span> <span class="o">-</span><span class="n">vX</span>
            <span class="n">vDeg</span> <span class="o">=</span> <span class="mi">270</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vVal</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vX</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">vY</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># 1st quad</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vX</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">vY</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">vDeg</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">vX</span> <span class="o">/</span> <span class="n">vY</span><span class="p">))</span>
        <span class="c1"># 2nd quad</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">vX</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">vY</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">vDeg</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">vX</span> <span class="o">/</span> <span class="n">vY</span><span class="p">))</span>
        <span class="c1"># 3rd quad</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">vX</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">vY</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">vDeg</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">vX</span> <span class="o">/</span> <span class="n">vY</span><span class="p">))</span>
        <span class="c1"># 4th quad</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">vX</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">vY</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">vDeg</span> <span class="o">=</span> <span class="mi">360</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">vX</span> <span class="o">/</span> <span class="n">vY</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">vVal</span><span class="p">,</span> <span class="n">vDeg</span><span class="p">)</span></div>


<div class="viewcode-block" id="ptXY2LatLonMercator">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.ptXY2LatLonMercator">[docs]</a>
<span class="k">def</span> <span class="nf">ptXY2LatLonMercator</span><span class="p">(</span><span class="n">ptXY</span><span class="p">:</span> <span class="n">pt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pt</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a point in (x, y), map it to a (lat, lon) coordinate using Mercator projection</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ptXY: pt, required</span>
<span class="sd">        The coordinate in (x, y)</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    tuple</span>
<span class="sd">        The coordinate in (lat, lon)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Ref: https://wiki.openstreetmap.org/wiki/Mercator#Python</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">ptXY</span>
    <span class="n">lon</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">y</span> <span class="o">/</span> <span class="n">CONST_EARTH_RADIUS_METERS</span><span class="p">)</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">CONST_EARTH_RADIUS_METERS</span><span class="p">))</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">ptLatLon</span> <span class="o">=</span> <span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ptLatLon</span></div>


<div class="viewcode-block" id="ptLatLon2XYMercator">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.ptLatLon2XYMercator">[docs]</a>
<span class="k">def</span> <span class="nf">ptLatLon2XYMercator</span><span class="p">(</span><span class="n">ptLatLon</span><span class="p">:</span> <span class="n">pt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pt</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a point in (lat, lon), map it to a (x, y) coordinate using Mercator projection</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ptLatLon: pt, required</span>
<span class="sd">        The coordinate in (lat, lon)</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    tuple</span>
<span class="sd">        The coordinate in (x, y)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Ref: https://wiki.openstreetmap.org/wiki/Mercator#Python</span>
    <span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">)</span> <span class="o">=</span> <span class="n">ptLatLon</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">*</span> <span class="n">CONST_EARTH_RADIUS_METERS</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">CONST_EARTH_RADIUS_METERS</span>
    <span class="n">ptXY</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ptXY</span></div>


<span class="c1"># Polys =======================================================================</span>
<div class="viewcode-block" id="polysUnion">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.polysUnion">[docs]</a>
<span class="k">def</span> <span class="nf">polysUnion</span><span class="p">(</span><span class="n">polys</span><span class="p">:</span><span class="n">polys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polysShapely</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">returnShaplelyObj</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of polygons which could be intersecting to each other, return unioned polygons that are not intersecting</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polys: poly, optional, default as None</span>
<span class="sd">        A list of polygons</span>
<span class="sd">    polysShapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely objects for polygons. Need to provide one of the following fields: [`polys`, `polysShapely`]</span>
<span class="sd">    returnShaplelyObj: bool, optional, default as False</span>
<span class="sd">        True if alter the result to be a shapely object</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    list of polys</span>
<span class="sd">        A list of polygons</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">polys</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">polysShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: Missing required field &#39;polys&#39; or &#39;polysShapely&#39;.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">polysShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">polysShapely</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
            <span class="n">polysShapely</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="n">unionAll</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">union_all</span><span class="p">(</span><span class="n">polysShapely</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">returnShaplelyObj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">unionAll</span>

    <span class="n">unionPolys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">unionAll</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">polygon</span><span class="o">.</span><span class="n">Polygon</span><span class="p">)):</span>
        <span class="n">unionPolys</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">unionAll</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)]]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">unionAll</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">multipolygon</span><span class="o">.</span><span class="n">MultiPolygon</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">unionAll</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
            <span class="n">unionPolys</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)])</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unionPolys</span><span class="p">)):</span>
        <span class="n">unionPolys</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">unionPolys</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unionPolys</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="k">if</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">unionPolys</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">unionPolys</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">CONST_EPSILON</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">unionPolys</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">unionPolys</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">CONST_EPSILON</span><span class="p">):</span>
            <span class="n">unionPolys</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">unionPolys</span><span class="p">[</span><span class="n">k</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">unionPolys</span></div>


<div class="viewcode-block" id="polysSubtract">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.polysSubtract">[docs]</a>
<span class="k">def</span> <span class="nf">polysSubtract</span><span class="p">(</span><span class="n">polys</span><span class="p">:</span><span class="n">polys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polysShapely</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subPolys</span><span class="p">:</span><span class="n">polys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subPolysShapely</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">returnShaplelyObj</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of polygons, subtract a list of polygon from the first list of polygons</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polys: poly, optional, default as None</span>
<span class="sd">        A list of polygons</span>
<span class="sd">    polysShapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely objects for polygons. Need to provide one of the following fields: [`polys`, `polysShapely`]</span>
<span class="sd">    subPolys: poly, optional, default as None</span>
<span class="sd">        A list of polygons to substract</span>
<span class="sd">    subPolysShapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely objects for polygons. Need to provide one of the following fields: [`subPolys`, `subPolysShapely`]    </span>

<span class="sd">    returnShaplelyObj: bool, optional, default as False</span>
<span class="sd">        True if alter the result to be a shapely object</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    list of polys</span>
<span class="sd">        A list of polygons</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">polys</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">polysShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: Missing required field &#39;polys&#39; or &#39;polysShapely&#39;.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">subPolys</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">subPolysShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: Missing required field &#39;subPolys&#39; or &#39;subPolysShapely&#39;.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">polysShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">polysShapely</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
            <span class="n">polysShapely</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="n">unionAll</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">union_all</span><span class="p">(</span><span class="n">polysShapely</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">subPolysShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">subPolysShapely</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">subPolys</span><span class="p">:</span>
            <span class="n">subPolysShapely</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="n">unionSub</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">union_all</span><span class="p">(</span><span class="n">subPolysShapely</span><span class="p">)</span>

    <span class="n">diffShapely</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">unionAll</span><span class="p">,</span> <span class="n">unionSub</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">returnShaplelyObj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">diffShapely</span>

    <span class="n">diffPolys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">diffShapely</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">polygon</span><span class="o">.</span><span class="n">Polygon</span><span class="p">)):</span>
        <span class="n">diffPolys</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">diffShapely</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)]]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">diffShapely</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">multipolygon</span><span class="o">.</span><span class="n">MultiPolygon</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">diffShapely</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
            <span class="n">diffPolys</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)])</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diffPolys</span><span class="p">)):</span>
        <span class="n">diffPolys</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">diffPolys</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diffPolys</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="k">if</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">diffPolys</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">diffPolys</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">CONST_EPSILON</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">diffPolys</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">diffPolys</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">CONST_EPSILON</span><span class="p">):</span>
            <span class="n">diffPolys</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">diffPolys</span><span class="p">[</span><span class="n">k</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">diffPolys</span></div>


<div class="viewcode-block" id="polysIntersect">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.polysIntersect">[docs]</a>
<span class="k">def</span> <span class="nf">polysIntersect</span><span class="p">(</span><span class="n">polys</span><span class="p">:</span> <span class="n">polys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polysShapely</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">returnShaplelyObj</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of polygons which could be intersecting to each other, return the intersecting polygons</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polys: poly, optional, default as None</span>
<span class="sd">        A list of polygons</span>
<span class="sd">    polysShapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely objects for polygons. Need to provide one of the following fields: [`polys`, `polysShapely`]</span>
<span class="sd">    returnShaplelyObj: bool, optional, default as False</span>
<span class="sd">        True if alter the result to be a shapely object</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    list of polys</span>
<span class="sd">        A list of polygons</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">polys</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">polysShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: Missing required field &#39;polys&#39; or &#39;polysShapely&#39;.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">polysShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">polysShapely</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
            <span class="n">polysShapely</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="n">intersectionAll</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">intersection_all</span><span class="p">(</span><span class="n">polysShapely</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">returnShaplelyObj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">intersectionAll</span>

    <span class="n">intersectionPoly</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">intersectionAll</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">polygon</span><span class="o">.</span><span class="n">Polygon</span><span class="p">)):</span>
        <span class="n">intersectionPoly</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">intersectionAll</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)]]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">intersectionAll</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">multipolygon</span><span class="o">.</span><span class="n">MultiPolygon</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">intersectionAll</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
            <span class="n">intersectionPoly</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)])</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intersectionPoly</span><span class="p">)):</span>
        <span class="n">intersectionPoly</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">intersectionPoly</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intersectionPoly</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="k">if</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">intersectionPoly</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">intersectionPoly</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">CONST_EPSILON</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">intersectionPoly</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">intersectionPoly</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">CONST_EPSILON</span><span class="p">):</span>
            <span class="n">intersectionPoly</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">intersectionPoly</span><span class="p">[</span><span class="n">k</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">intersectionPoly</span></div>


<div class="viewcode-block" id="polysSteinerZone">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.polysSteinerZone">[docs]</a>
<span class="k">def</span> <span class="nf">polysSteinerZone</span><span class="p">(</span><span class="n">polys</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a node dictionary, returns a list of Steiner zones</span>

<span class="sd">    Warning!!!</span>
<span class="sd">    ----------</span>
<span class="sd">    This function needs to be rewritten. It&#39;s not traceable now.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    polys: dictionary, required</span>
<span class="sd">        The polys dictionary with neighborhood.</span>
<span class="sd">    order: int, optional, default None</span>
<span class="sd">        Maximum order of Steiner zone</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    list[dict]</span>
<span class="sd">        A list of Steiner zone dictionaries, each in the following format::</span>
<span class="sd">            &gt;&gt;&gt; SteinerZone = {</span>
<span class="sd">            ...     &#39;poly&#39;: poly,</span>
<span class="sd">            ...     &#39;repPt&#39;: centroid,</span>
<span class="sd">            ...     &#39;nodeID&#39;: []</span>
<span class="sd">            ... }</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># List of Steiner Zones</span>
    <span class="n">lstSteinerZone</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lstSteinerZoneShape</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Check overlapping</span>
    <span class="n">overlapMatrix</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">registeredSZ</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># First check by any two pairs of neighbor</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">):</span>
                <span class="n">neiI</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;poly&#39;</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                    <span class="n">neiI</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;poly&#39;</span><span class="p">]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">neiI</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Point</span><span class="p">([</span><span class="n">polys</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">polys</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">neiJ</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;poly&#39;</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                    <span class="n">neiJ</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;poly&#39;</span><span class="p">]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">neiJ</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Point</span><span class="p">([</span><span class="n">polys</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">polys</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>

                <span class="n">intersectIJ</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">neiI</span><span class="p">,</span> <span class="n">neiJ</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">intersectIJ</span><span class="o">.</span><span class="n">is_empty</span><span class="p">):</span>
                    <span class="n">overlapMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">overlapMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>                    
                    <span class="n">lstSteinerZoneShape</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                            <span class="s1">&#39;polyShape&#39;</span><span class="p">:</span> <span class="n">intersectIJ</span><span class="p">,</span>
                            <span class="s1">&#39;repPtShape&#39;</span><span class="p">:</span> <span class="n">intersectIJ</span><span class="o">.</span><span class="n">centroid</span><span class="p">,</span>
                            <span class="s1">&#39;nodeIDs&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                        <span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">overlapMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">overlapMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># If no two neighbor are overlapped, every neighborhood is a Steiner Zone of order 1</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">overlapMatrix</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="s1">&#39;poly&#39;</span><span class="p">:</span> <span class="n">polys</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;poly&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;poly&#39;</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">else</span> <span class="p">[</span><span class="n">polys</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">]],</span>
                <span class="s1">&#39;repPt&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;poly&#39;</span><span class="p">]])</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="s1">&#39;poly&#39;</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">else</span> <span class="n">polys</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span>
                <span class="s1">&#39;nodeIDs&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="p">}</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">]</span>

    <span class="n">pointer</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">checkOrder</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">checkOrder</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">order</span> <span class="k">if</span> <span class="n">order</span> <span class="o">!=</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">))):</span>
        <span class="c1"># Q: How many SZ needs to be checked? A: From `pointer` to `endPointer`</span>
        <span class="n">endPointer</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lstSteinerZoneShape</span><span class="p">)</span>

        <span class="c1"># Check each SZ in this order, to see if it can be increase by order 1</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span> <span class="n">endPointer</span><span class="p">):</span>
            <span class="c1"># Get a SZ, see if there is a node n intersect with this SZ</span>
            <span class="n">SZShape</span> <span class="o">=</span> <span class="n">lstSteinerZoneShape</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
                <span class="c1"># First, n should not be a SZ member</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SZShape</span><span class="p">[</span><span class="s1">&#39;nodeIDs&#39;</span><span class="p">]):</span>
                    <span class="c1"># Assume all neighbor in SZShape is intersected with n</span>
                    <span class="n">overlapAllFlag</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># Check one by one, if one of neighbor is not intersected with n, skip</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">SZShape</span><span class="p">[</span><span class="s1">&#39;nodeIDs&#39;</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">overlapMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="n">overlapAllFlag</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">overlapAllFlag</span><span class="p">):</span>
                        <span class="n">newNodeIDs</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">SZShape</span><span class="p">[</span><span class="s1">&#39;nodeIDs&#39;</span><span class="p">]]</span>
                        <span class="n">newNodeIDs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">list2Tuple</span><span class="p">(</span><span class="n">newNodeIDs</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">registeredSZ</span><span class="p">):</span>
                            <span class="c1"># The neighbor of node n could be either a Polygon or a Point</span>
                            <span class="n">neiN</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;poly&#39;</span><span class="p">]])</span> <span class="k">if</span> <span class="s1">&#39;poly&#39;</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">else</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">])</span>
                            <span class="n">newIntersect</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">SZShape</span><span class="p">[</span><span class="s1">&#39;polyShape&#39;</span><span class="p">],</span> <span class="n">neiN</span><span class="p">)</span>
                            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">newIntersect</span><span class="o">.</span><span class="n">is_empty</span><span class="p">):</span>
                                <span class="n">registeredSZ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">list2Tuple</span><span class="p">(</span><span class="n">newNodeIDs</span><span class="p">))</span>
                                <span class="n">lstSteinerZoneShape</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                                        <span class="s1">&#39;polyShape&#39;</span><span class="p">:</span> <span class="n">newIntersect</span><span class="p">,</span>
                                        <span class="s1">&#39;repPtShape&#39;</span><span class="p">:</span> <span class="n">newIntersect</span><span class="o">.</span><span class="n">centroid</span><span class="p">,</span>
                                        <span class="s1">&#39;nodeIDs&#39;</span><span class="p">:</span> <span class="n">newNodeIDs</span>
                                    <span class="p">})</span>

        <span class="c1"># Set `pointer` to be `endPointer`</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="n">endPointer</span>
        <span class="n">checkOrder</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">lstSteinerZone</span> <span class="o">=</span> <span class="p">[{</span>
        <span class="s1">&#39;poly&#39;</span><span class="p">:</span> <span class="n">polys</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;poly&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;poly&#39;</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">else</span> <span class="p">[</span><span class="n">polys</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">]],</span>
        <span class="s1">&#39;repPt&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;poly&#39;</span><span class="p">]])</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="s1">&#39;poly&#39;</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">else</span> <span class="n">polys</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span>
        <span class="s1">&#39;nodeIDs&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="p">}</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">lstSteinerZoneShape</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="s1">&#39;polyShape&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Point</span><span class="p">):</span>
            <span class="n">lstSteinerZone</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;poly&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="n">n</span><span class="p">[</span><span class="s1">&#39;polyShape&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="s1">&#39;polyShape&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">]],</span>
                <span class="s1">&#39;repPt&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="s1">&#39;repPtShape&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="s1">&#39;nodeIDs&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="p">[</span><span class="s1">&#39;nodeIDs&#39;</span><span class="p">]]</span>
            <span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lstSteinerZone</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;poly&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="s1">&#39;polyShape&#39;</span><span class="p">])[</span><span class="s1">&#39;coordinates&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
                <span class="s1">&#39;repPt&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="s1">&#39;repPtShape&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="s1">&#39;nodeIDs&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="p">[</span><span class="s1">&#39;nodeIDs&#39;</span><span class="p">]]</span>
            <span class="p">})</span>    

    <span class="k">return</span> <span class="n">lstSteinerZone</span></div>

 
<div class="viewcode-block" id="polysBoundingBox">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.polysBoundingBox">[docs]</a>
<span class="k">def</span> <span class="nf">polysBoundingBox</span><span class="p">(</span><span class="n">polys</span><span class="p">:</span><span class="n">polys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polysShapely</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">polys</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">polysShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: Missing required field &#39;polys&#39; or &#39;polysShapely&#39;.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">polys</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polyShapely</span><span class="p">:</span>
            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="s1">&#39;coordinates&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
    <span class="n">polysBox</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">polysBox</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">)])</span>

    <span class="k">return</span> <span class="n">polysBox</span></div>


<div class="viewcode-block" id="polygonsAlongLocSeq">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.polygonsAlongLocSeq">[docs]</a>
<span class="k">def</span> <span class="nf">polygonsAlongLocSeq</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">polygons</span><span class="p">:</span><span class="nb">dict</span><span class="p">,</span> <span class="n">polyFieldName</span> <span class="o">=</span> <span class="s1">&#39;poly&#39;</span><span class="p">):</span>
     <span class="c1"># First, for each leg in the seq, find the individual polygons intersect with the leg</span>
    <span class="n">actions</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">actionIDOnLeg</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">seg</span> <span class="o">=</span> <span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># NOTE: 准备用segment tree</span>
        <span class="c1"># NOTE: For now use the naive way - checking the bounding box</span>
        <span class="k">for</span> <span class="n">pID</span> <span class="ow">in</span> <span class="n">polygons</span><span class="p">:</span>
            <span class="c1"># 根据Seg和poly的相交情况做判断</span>
            <span class="n">segIntPoly</span> <span class="o">=</span> <span class="n">intSeg2Poly</span><span class="p">(</span><span class="n">seg</span> <span class="o">=</span> <span class="n">seg</span><span class="p">,</span> <span class="n">poly</span> <span class="o">=</span> <span class="n">polygons</span><span class="p">[</span><span class="n">pID</span><span class="p">][</span><span class="n">polyFieldName</span><span class="p">])</span>
            <span class="c1"># if (type(segIntPoly) == list or segIntPoly[&#39;status&#39;] != &#39;NoCross&#39;):</span>
                <span class="c1"># print(segIntPoly, pID)</span>
            <span class="c1"># 如果相交得到多个部分，则分别进行处理</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">segIntPoly</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">intPart</span> <span class="ow">in</span> <span class="n">segIntPoly</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">intPart</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Cross&#39;</span> <span class="ow">and</span> <span class="n">intPart</span><span class="p">[</span><span class="s1">&#39;intersectType&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Point&#39;</span><span class="p">):</span>
                        <span class="n">intPt</span> <span class="o">=</span> <span class="n">segIntPoly</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">]</span>
                        <span class="n">actions</span><span class="p">[</span><span class="n">actionIDOnLeg</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">intPt</span><span class="p">,</span>
                            <span class="s1">&#39;action&#39;</span><span class="p">:</span> <span class="s1">&#39;touch&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">pID</span><span class="p">,</span>                       
                        <span class="p">}</span>
                        <span class="n">actionIDOnLeg</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">intPart</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Cross&#39;</span> <span class="ow">and</span> <span class="n">intPart</span><span class="p">[</span><span class="s1">&#39;intersectType&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Segment&#39;</span><span class="p">):</span>
                        <span class="n">intPt1</span> <span class="o">=</span> <span class="n">segIntPoly</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">intPt2</span> <span class="o">=</span> <span class="n">segIntPoly</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">intPt1InnerFlag</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">intPt2InnerFlag</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">isPtInPoly</span><span class="p">(</span><span class="n">intPt1</span><span class="p">,</span> <span class="n">polygons</span><span class="p">[</span><span class="n">pID</span><span class="p">][</span><span class="n">polyFieldName</span><span class="p">],</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">True</span><span class="p">)):</span>
                            <span class="n">intPt1InnerFlag</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">isPtInPoly</span><span class="p">(</span><span class="n">intPt2</span><span class="p">,</span> <span class="n">polygons</span><span class="p">[</span><span class="n">pID</span><span class="p">][</span><span class="n">polyFieldName</span><span class="p">],</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">True</span><span class="p">)):</span>
                            <span class="n">intPt2InnerFlag</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">intPt1</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">&lt;</span>
                            <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">intPt2</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]):</span>
                            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">intPt1InnerFlag</span><span class="p">):</span>
                                <span class="n">actions</span><span class="p">[</span><span class="n">actionIDOnLeg</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                                    <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">intPt1</span><span class="p">,</span>
                                    <span class="s1">&#39;action&#39;</span><span class="p">:</span> <span class="s1">&#39;enter&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">pID</span><span class="p">,</span>
                                <span class="p">}</span>
                                <span class="n">actionIDOnLeg</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">intPt2InnerFlag</span><span class="p">):</span>
                                <span class="n">actions</span><span class="p">[</span><span class="n">actionIDOnLeg</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                                    <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">intPt2</span><span class="p">,</span>
                                    <span class="s1">&#39;action&#39;</span><span class="p">:</span> <span class="s1">&#39;leave&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">pID</span><span class="p">,</span>
                                <span class="p">}</span>
                                <span class="n">actionIDOnLeg</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">intPt1InnerFlag</span><span class="p">):</span>
                                <span class="n">actions</span><span class="p">[</span><span class="n">actionIDOnLeg</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                                    <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">intPt1</span><span class="p">,</span>
                                    <span class="s1">&#39;action&#39;</span><span class="p">:</span> <span class="s1">&#39;leave&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">pID</span><span class="p">,</span>
                                <span class="p">}</span>
                                <span class="n">actionIDOnLeg</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">intPt2InnerFlag</span><span class="p">):</span>
                                <span class="n">actions</span><span class="p">[</span><span class="n">actionIDOnLeg</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                                    <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">intPt2</span><span class="p">,</span>
                                    <span class="s1">&#39;action&#39;</span><span class="p">:</span> <span class="s1">&#39;enter&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">pID</span><span class="p">,</span>
                                <span class="p">}</span>
                                <span class="n">actionIDOnLeg</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">segIntPoly</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;NoCross&#39;</span><span class="p">):</span>
                    <span class="c1"># No intersection pass</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">segIntPoly</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Cross&#39;</span> <span class="ow">and</span> <span class="n">segIntPoly</span><span class="p">[</span><span class="s1">&#39;intersectType&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Point&#39;</span><span class="p">):</span>
                    <span class="n">intPt</span> <span class="o">=</span> <span class="n">segIntPoly</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">]</span>
                    <span class="n">actions</span><span class="p">[</span><span class="n">actionIDOnLeg</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">intPt</span><span class="p">,</span>
                        <span class="s1">&#39;action&#39;</span><span class="p">:</span> <span class="s1">&#39;touch&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">pID</span><span class="p">,</span>
                    <span class="p">}</span>
                    <span class="n">actionIDOnLeg</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">segIntPoly</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Cross&#39;</span> <span class="ow">and</span> <span class="n">segIntPoly</span><span class="p">[</span><span class="s1">&#39;intersectType&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Segment&#39;</span><span class="p">):</span>
                    <span class="n">intPt1</span> <span class="o">=</span> <span class="n">segIntPoly</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">intPt2</span> <span class="o">=</span> <span class="n">segIntPoly</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">intPt1InnerFlag</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">intPt2InnerFlag</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">isPtInPoly</span><span class="p">(</span><span class="n">intPt1</span><span class="p">,</span> <span class="n">polygons</span><span class="p">[</span><span class="n">pID</span><span class="p">][</span><span class="n">polyFieldName</span><span class="p">],</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">True</span><span class="p">)):</span>
                        <span class="n">intPt1InnerFlag</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">isPtInPoly</span><span class="p">(</span><span class="n">intPt2</span><span class="p">,</span> <span class="n">polygons</span><span class="p">[</span><span class="n">pID</span><span class="p">][</span><span class="n">polyFieldName</span><span class="p">],</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">True</span><span class="p">)):</span>
                        <span class="n">intPt2InnerFlag</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">intPt1</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">&lt;</span>
                        <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">intPt2</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">intPt1InnerFlag</span><span class="p">):</span>
                            <span class="n">actions</span><span class="p">[</span><span class="n">actionIDOnLeg</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                                <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">intPt1</span><span class="p">,</span>
                                <span class="s1">&#39;action&#39;</span><span class="p">:</span> <span class="s1">&#39;enter&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">pID</span><span class="p">,</span>
                            <span class="p">}</span>
                            <span class="n">actionIDOnLeg</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">intPt2InnerFlag</span><span class="p">):</span>
                            <span class="n">actions</span><span class="p">[</span><span class="n">actionIDOnLeg</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                                <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">intPt2</span><span class="p">,</span>
                                <span class="s1">&#39;action&#39;</span><span class="p">:</span> <span class="s1">&#39;leave&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">pID</span><span class="p">,</span>
                            <span class="p">}</span>
                            <span class="n">actionIDOnLeg</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">intPt1InnerFlag</span><span class="p">):</span>
                            <span class="n">actions</span><span class="p">[</span><span class="n">actionIDOnLeg</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                                <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">intPt1</span><span class="p">,</span>
                                <span class="s1">&#39;action&#39;</span><span class="p">:</span> <span class="s1">&#39;leave&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">pID</span><span class="p">,</span>
                            <span class="p">}</span>
                            <span class="n">actionIDOnLeg</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">intPt2InnerFlag</span><span class="p">):</span>
                            <span class="n">actions</span><span class="p">[</span><span class="n">actionIDOnLeg</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                                <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">intPt2</span><span class="p">,</span>
                                <span class="s1">&#39;action&#39;</span><span class="p">:</span> <span class="s1">&#39;enter&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">pID</span><span class="p">,</span>
                            <span class="p">}</span>
                            <span class="n">actionIDOnLeg</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">sortedIDOnLeg</span> <span class="o">=</span> <span class="n">locSeqSortNodes</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">allowNotIncludeFlag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)[</span><span class="s1">&#39;sortedNodeIDs&#39;</span><span class="p">]</span>

    <span class="n">sortedActions</span> <span class="o">=</span> <span class="p">[</span><span class="n">actions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sortedIDOnLeg</span><span class="p">]</span>
    <span class="n">sortedActions</span> <span class="o">=</span> <span class="p">[</span><span class="n">sortedActions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sortedActions</span><span class="p">))</span> <span class="k">if</span> <span class="p">(</span>
        <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="ow">or</span> <span class="ow">not</span> <span class="n">is2PtsSame</span><span class="p">(</span><span class="n">sortedActions</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span> <span class="n">sortedActions</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">]))]</span>

    <span class="k">return</span> <span class="n">sortedActions</span></div>


<div class="viewcode-block" id="ptPolyCenter">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.ptPolyCenter">[docs]</a>
<span class="k">def</span> <span class="nf">ptPolyCenter</span><span class="p">(</span><span class="n">poly</span><span class="p">:</span> <span class="n">poly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polyShapely</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pt</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a poly, returns the centroid of the poly</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    poly: poly, optional, default as None</span>
<span class="sd">        The polygon</span>
<span class="sd">    polyShapely: shapely.Polygon, optional, default as None</span>
<span class="sd">        The correspond shapely object for polygon. Need to provide one of the following fields: [`poly`, `polyShapely`]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pt</span>
<span class="sd">        The centroid</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">poly</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">polyShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: Missing required field &#39;poly&#39; or &#39;polyShapely&#39;.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">polyShapely</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">polyShapely</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>

    <span class="n">ptShapely</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">centroid</span><span class="p">(</span><span class="n">polyShapely</span><span class="p">)</span>
    <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">ptShapely</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">ptShapely</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">center</span></div>


<span class="c1"># Visibility check ============================================================</span>
<div class="viewcode-block" id="polysVisibleGraph">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.polysVisibleGraph">[docs]</a>
<span class="k">def</span> <span class="nf">polysVisibleGraph</span><span class="p">(</span><span class="n">polys</span><span class="p">:</span><span class="n">polys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a visual graph for given polys.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polys: polys, required</span>
<span class="sd">        The polys to create visual graph</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        Each polygon has a index p, each point in the polygon has a index e, therefore, a (p, e) pair defines a location. The visual graph returns use (p, e) as keys, collects the location of (p, e) in &#39;loc&#39;, and finds the set of visible (p, e) in &#39;visible&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">vg</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">p</span><span class="p">])):</span>
            <span class="n">vg</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">polys</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">e</span><span class="p">],</span> <span class="s1">&#39;visible&#39;</span><span class="p">:</span> <span class="p">[]}</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">_visPtAmongPolys</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span> <span class="n">polys</span><span class="p">,</span> <span class="n">knownVG</span><span class="o">=</span><span class="n">vg</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">W</span><span class="p">:</span>
                <span class="n">vg</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">)][</span><span class="s1">&#39;visible&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vg</span></div>


<span class="k">def</span> <span class="nf">_visPtAmongPolys</span><span class="p">(</span><span class="n">v</span><span class="p">:</span><span class="nb">int</span><span class="o">|</span><span class="nb">str</span><span class="o">|</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">polys</span><span class="p">:</span><span class="n">polys</span><span class="p">,</span> <span class="n">standalonePts</span><span class="p">:</span><span class="nb">dict</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">knownVG</span><span class="p">:</span><span class="nb">dict</span><span class="o">=</span><span class="p">{})</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="c1"># NOTE: 该函数不需要使用shapely</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">polyVertices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">p</span><span class="p">])):</span>
            <span class="n">vertices</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">polys</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">e</span><span class="p">],</span>
                <span class="s1">&#39;visible&#39;</span><span class="p">:</span> <span class="p">[]</span>
            <span class="p">}</span>
            <span class="n">polyVertices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">standalonePts</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">standalonePts</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: Cannot find `v` in `polys` or `standalonePts`&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">standalonePts</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span>
                <span class="s1">&#39;visible&#39;</span><span class="p">:</span> <span class="p">[]</span>
            <span class="p">}</span>

    <span class="c1"># 把所有的poly vertices按到v的距离排序，从而给每个点得到一个可排序的唯一编码</span>
    <span class="n">verticeDistIndex</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">sortedSeq</span> <span class="o">=</span> <span class="n">nodeSeqByDist</span><span class="p">(</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">,</span>
        <span class="n">refLoc</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span>
        <span class="n">nodeIDs</span> <span class="o">=</span> <span class="n">polyVertices</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sortedSeq</span><span class="p">)):</span>
        <span class="n">verticeDistIndex</span><span class="p">[</span><span class="n">sortedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="c1"># 把所有的poly vertices按到v的角度排序，从x轴正方向开始，从而得到后续可视性检查的顺序</span>
    <span class="n">sweepSeq</span> <span class="o">=</span> <span class="n">nodeSeqBySweeping</span><span class="p">(</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">,</span>
        <span class="n">nodeIDs</span> <span class="o">=</span> <span class="n">polyVertices</span><span class="p">,</span>
        <span class="n">refLoc</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span>
        <span class="n">initDeg</span> <span class="o">=</span> <span class="mi">90</span><span class="p">)</span>

    <span class="c1"># 用一个红黑树来维护射线通过的边，边的键值用(closer-index, further-index)，这样排序的时候无论如何都能保持距离关系</span>
    <span class="k">def</span> <span class="nf">rayIntersectPolyEdges</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="n">polys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RedBlackTree</span><span class="p">:</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">RedBlackTree</span><span class="p">()</span>
        <span class="c1"># FIXME: 这个显然需要用线段树来优化，在这里就先实现再说吧</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="p">[</span><span class="n">polys</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">polys</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="c1"># NOTE: 注意，这里射线可以与线段交于端点上</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">isSegIntRay</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">ray</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">True</span><span class="p">)):</span>
                    <span class="c1"># NOTE: 防止数组溢出</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">vIdx1</span> <span class="o">=</span> <span class="n">verticeDistIndex</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span>
                    <span class="n">vIdx2</span> <span class="o">=</span> <span class="n">verticeDistIndex</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                    <span class="n">T</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">RedBlackTreeNode</span><span class="p">(</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">vIdx1</span><span class="p">,</span> <span class="n">vIdx2</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">vIdx1</span><span class="p">,</span> <span class="n">vIdx2</span><span class="p">)),</span> 
                        <span class="n">value</span> <span class="o">=</span> <span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]))</span>
        <span class="k">return</span> <span class="n">T</span>

    <span class="c1"># 初始射线方向为x-轴正方向</span>
    <span class="n">xAxisRay</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span> <span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])]</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">rayIntersectPolyEdges</span><span class="p">(</span><span class="n">xAxisRay</span><span class="p">,</span> <span class="n">polys</span><span class="p">)</span>

    <span class="c1"># 给定一个障碍物的顶点w_i，确定v是否可以见到w_i</span>
    <span class="c1"># NOTE: 这里的wi, wim（也就是w_{i-1})得是polys的顶点</span>
    <span class="k">def</span> <span class="nf">visible</span><span class="p">(</span><span class="n">wi</span><span class="p">,</span> <span class="n">wim</span><span class="p">,</span> <span class="n">polys</span><span class="p">):</span>
        <span class="c1"># 如果wiv已经确定可视，直接返回True</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">wi</span> <span class="ow">in</span> <span class="n">knownVG</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">knownVG</span><span class="p">[</span><span class="n">wi</span><span class="p">][</span><span class="s1">&#39;visible&#39;</span><span class="p">]):</span>
            <span class="c1"># print(&quot;Time saved&quot;)</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># 所在的polygon的编号</span>
        <span class="n">polyV</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">polyW</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">wi</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">vwi</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[</span><span class="n">wi</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">]]</span>

        <span class="n">vNext</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">vPrev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">vNext</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">vPrev</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">wiNext</span> <span class="o">=</span> <span class="p">(</span><span class="n">wi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">wi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">wi</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">wiPrev</span> <span class="o">=</span> <span class="p">(</span><span class="n">wi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">wi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">wi</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>        

        <span class="c1"># 判断是否是相邻节点，相邻节点直接返回可见</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">polyV</span> <span class="o">==</span> <span class="n">polyW</span> <span class="ow">and</span> <span class="p">(</span><span class="n">wi</span> <span class="o">==</span> <span class="n">vNext</span> <span class="ow">or</span> <span class="n">wi</span> <span class="o">==</span> <span class="n">vPrev</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># 需要w_{i-1}不存在，或者w_{i-1}不在线段vwi上</span>
        <span class="n">notOnlineFlag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">wim</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isPtOnSeg</span><span class="p">(</span><span class="n">wim</span><span class="p">,</span> <span class="n">vwi</span><span class="p">)):</span>
            <span class="n">notOnlineFlag</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># 若T非空，查有没有阻拦线段</span>
        <span class="n">noSegBlockFlag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">notOnlineFlag</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">T</span><span class="o">.</span><span class="n">isEmpty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">T</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">root</span><span class="p">)</span><span class="o">.</span><span class="n">isNil</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">isSegIntSeg</span><span class="p">(</span>
                        <span class="n">seg1</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;loc&#39;</span><span class="p">]],</span> 
                        <span class="n">seg2</span> <span class="o">=</span> <span class="n">vwi</span><span class="p">,</span> 
                        <span class="n">interiorOnly</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)):</span>
                    <span class="n">noSegBlockFlag</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

        <span class="c1"># 如果visibleFlag，查交点上是否相切</span>
        <span class="n">int2PolyVTangenFlag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">int2PolyWTangenFlag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">noSegBlockFlag</span><span class="p">):</span>
            <span class="c1"># Check point V</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">polyV</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">int2PolyVTangenFlag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">segV</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[</span><span class="n">vNext</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[</span><span class="n">vPrev</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">]]</span>
                <span class="n">int2PolyVTangenFlag</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">isLineIntSeg</span><span class="p">(</span><span class="n">vwi</span><span class="p">,</span> <span class="n">segV</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">int2PolyVTangenFlag</span><span class="p">):</span>
            <span class="c1"># Check point W</span>
            <span class="n">segW</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[</span><span class="n">wiNext</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[</span><span class="n">wiPrev</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">]]</span>
            <span class="n">int2PolyWTangenFlag</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">isLineIntSeg</span><span class="p">(</span><span class="n">vwi</span><span class="p">,</span> <span class="n">segW</span><span class="p">,</span> <span class="n">interiorOnly</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">bothEndTangenFlag</span> <span class="o">=</span> <span class="n">int2PolyVTangenFlag</span> <span class="ow">and</span> <span class="n">int2PolyWTangenFlag</span>

        <span class="c1"># 如果没有阻挡线段，查是不是在多边形内部</span>
        <span class="c1"># NOTE: 似乎可以通过查中点确定是不是在多边形内部</span>
        <span class="n">visibleFlag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">noSegBlockFlag</span> <span class="ow">and</span> <span class="n">bothEndTangenFlag</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isSegIntPoly</span><span class="p">(</span>
                <span class="n">seg</span> <span class="o">=</span> <span class="n">vwi</span><span class="p">,</span>
                <span class="n">poly</span> <span class="o">=</span> <span class="n">polyW</span><span class="p">,</span>
                <span class="n">interiorOnly</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)):</span>
            <span class="n">visibleFlag</span> <span class="o">=</span> <span class="kc">True</span>        


        <span class="k">if</span> <span class="p">(</span><span class="n">visibleFlag</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># 前面任何一关不通过，则不可视</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">W</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sweepSeq</span><span class="p">)):</span>
        <span class="n">wi</span> <span class="o">=</span> <span class="n">sweepSeq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">wim</span> <span class="o">=</span> <span class="n">sweepSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="c1"># print(T)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is2PtsSame</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[</span><span class="n">wi</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="n">visible</span><span class="p">(</span><span class="n">wi</span><span class="p">,</span> <span class="n">wim</span><span class="p">,</span> <span class="n">polys</span><span class="p">)):</span>
            <span class="n">W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wi</span><span class="p">)</span>

        <span class="c1"># 将wi的边加入/移出平衡树T</span>
        <span class="c1"># wi所在的poly编号</span>
        <span class="n">polyIdx</span> <span class="o">=</span> <span class="n">wi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># wi在poly内的编号</span>
        <span class="n">idInPoly</span> <span class="o">=</span> <span class="n">wi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Edge 1: wi -&gt; wi.next</span>
        <span class="n">wiNext</span> <span class="o">=</span> <span class="p">(</span><span class="n">wi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">wi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">wi</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Edge 2: wi.prev -&gt; wi</span>
        <span class="n">wiPrev</span> <span class="o">=</span> <span class="p">(</span><span class="n">wi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">wi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">wi</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># 判断edgeNext</span>
        <span class="n">vIdxWi</span> <span class="o">=</span> <span class="n">verticeDistIndex</span><span class="p">[</span><span class="n">wi</span><span class="p">]</span>
        <span class="n">vIdxWiNext</span> <span class="o">=</span> <span class="n">verticeDistIndex</span><span class="p">[</span><span class="n">wiNext</span><span class="p">]</span>
        <span class="n">vIdxWiPrev</span> <span class="o">=</span> <span class="n">verticeDistIndex</span><span class="p">[</span><span class="n">wiPrev</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is3PtsClockWise</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[</span><span class="n">wi</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[</span><span class="n">wiNext</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">])):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">query</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">vIdxWi</span><span class="p">,</span> <span class="n">vIdxWiNext</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">vIdxWi</span><span class="p">,</span> <span class="n">vIdxWiNext</span><span class="p">)))</span><span class="o">.</span><span class="n">isNil</span><span class="p">):</span>
                <span class="n">T</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">RedBlackTreeNode</span><span class="p">(</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">vIdxWi</span><span class="p">,</span> <span class="n">vIdxWiNext</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">vIdxWi</span><span class="p">,</span> <span class="n">vIdxWiNext</span><span class="p">)),</span> 
                    <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">wi</span><span class="p">,</span> <span class="n">wiNext</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">T</span><span class="o">.</span><span class="n">query</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">vIdxWi</span><span class="p">,</span> <span class="n">vIdxWiNext</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">vIdxWi</span><span class="p">,</span> <span class="n">vIdxWiNext</span><span class="p">)))</span><span class="o">.</span><span class="n">isNil</span><span class="p">):</span>
                <span class="n">T</span><span class="o">.</span><span class="n">delete</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">vIdxWi</span><span class="p">,</span> <span class="n">vIdxWiNext</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">vIdxWi</span><span class="p">,</span> <span class="n">vIdxWiNext</span><span class="p">)))</span>        
        <span class="k">if</span> <span class="p">(</span><span class="n">is3PtsClockWise</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[</span><span class="n">wi</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[</span><span class="n">wiPrev</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">])):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">query</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">vIdxWiPrev</span><span class="p">,</span> <span class="n">vIdxWi</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">vIdxWiPrev</span><span class="p">,</span> <span class="n">vIdxWi</span><span class="p">)))</span><span class="o">.</span><span class="n">isNil</span><span class="p">):</span>
                <span class="n">T</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">RedBlackTreeNode</span><span class="p">(</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">vIdxWiPrev</span><span class="p">,</span> <span class="n">vIdxWi</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">vIdxWiPrev</span><span class="p">,</span> <span class="n">vIdxWi</span><span class="p">)),</span> 
                    <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">wiPrev</span><span class="p">,</span> <span class="n">wi</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">T</span><span class="o">.</span><span class="n">query</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">vIdxWiPrev</span><span class="p">,</span> <span class="n">vIdxWi</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">vIdxWiPrev</span><span class="p">,</span> <span class="n">vIdxWi</span><span class="p">)))</span><span class="o">.</span><span class="n">isNil</span><span class="p">):</span>
                <span class="n">T</span><span class="o">.</span><span class="n">delete</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">vIdxWiPrev</span><span class="p">,</span> <span class="n">vIdxWi</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">vIdxWiPrev</span><span class="p">,</span> <span class="n">vIdxWi</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">W</span>

<span class="c1"># Time seq related ============================================================</span>
<div class="viewcode-block" id="snapInTimedSeq">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.snapInTimedSeq">[docs]</a>
<span class="k">def</span> <span class="nf">snapInTimedSeq</span><span class="p">(</span><span class="n">timedSeq</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">pt</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pt</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a timedSeq, return the location, speed, and trajectory at time t</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    timedSeq: timedSeq, required</span>
<span class="sd">        The timed sequence</span>
<span class="sd">    t: float, required</span>
<span class="sd">        The snapshot timestamp</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    dict</span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;loc&#39;: location,</span>
<span class="sd">        ...     &#39;speed&#39;: speed,</span>
<span class="sd">        ...     &#39;trajectory&#39;: trajectory</span>
<span class="sd">        ... }</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">timedSeq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="n">UnsupportedInputError</span><span class="p">(</span><span class="s2">&quot;ERROR: `timedSeq` should be a non-descending sequence.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> 
            <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">CONST_EPSILON</span>
                <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">CONST_EPSILON</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">UnsupportedInputError</span><span class="p">(</span><span class="s2">&quot;ERROR: an object cannot be two places at the same time.&quot;</span><span class="p">)</span>

    <span class="n">curLocX</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">curLocY</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">curSpeed</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">curTrajectory</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">timedSeq</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;speed&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;trajectory&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">timedSeq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;speed&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;trajectory&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">timedSeq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>                
                <span class="n">curLocX</span> <span class="o">=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">dt</span>
                <span class="n">curLocY</span> <span class="o">=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">dt</span>
                <span class="n">curSpeed</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">/</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">trajX</span> <span class="o">=</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">dist</span>
                <span class="n">trajY</span> <span class="o">=</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">dist</span>
                <span class="n">curTrajectory</span> <span class="o">=</span> <span class="p">[(</span><span class="n">curLocX</span><span class="p">,</span> <span class="n">curLocY</span><span class="p">),</span> <span class="p">(</span><span class="n">curLocX</span> <span class="o">+</span> <span class="n">trajX</span><span class="p">,</span> <span class="n">curLocY</span> <span class="o">+</span> <span class="n">trajY</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curLocX</span> <span class="o">=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">curLocY</span> <span class="o">=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">curSpeed</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">curTrajectory</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">curLocX</span><span class="p">,</span> <span class="n">curLocY</span><span class="p">],</span>
        <span class="s1">&#39;speed&#39;</span><span class="p">:</span> <span class="n">curSpeed</span><span class="p">,</span>
        <span class="s1">&#39;trajectory&#39;</span><span class="p">:</span> <span class="n">curTrajectory</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="traceInTimedSeq">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.traceInTimedSeq">[docs]</a>
<span class="k">def</span> <span class="nf">traceInTimedSeq</span><span class="p">(</span><span class="n">timedSeq</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">pt</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">ts</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">te</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">pt</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a timedSeq, a start time and an end time, returns the trace between start time and end time.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    timedSeq: timedSeq, required</span>
<span class="sd">        The timed sequence</span>
<span class="sd">    ts: float, required</span>
<span class="sd">        The start time</span>
<span class="sd">    te: float, required</span>
<span class="sd">        The end time</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    list</span>
<span class="sd">        The line segment sequence between start time and end time in the timedSeq</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">timedSeq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="n">UnsupportedInputError</span><span class="p">(</span><span class="s2">&quot;ERROR: `timedSeq` should be a non-descending sequence.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> 
            <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">CONST_EPSILON</span>
                <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">CONST_EPSILON</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">UnsupportedInputError</span><span class="p">(</span><span class="s2">&quot;ERROR: an object cannot be two places at the same time.&quot;</span><span class="p">)</span>
    
    <span class="n">trace</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ts</span> <span class="o">&gt;=</span> <span class="n">te</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">UnsupportedInputError</span><span class="p">(</span><span class="s2">&quot;ERROR: `ts` should be earlier than `te`&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ts</span> <span class="o">&lt;=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">te</span> <span class="o">&gt;=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">timedSeq</span><span class="p">))]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ts</span> <span class="o">&gt;=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">te</span> <span class="o">&lt;=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="n">tsIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">teIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">tsLoc</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">teLoc</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ts</span> <span class="o">&lt;=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">tsIndex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">tsLoc</span> <span class="o">=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">te</span> <span class="o">&gt;=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">teIndex</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">timedSeq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">te</span> <span class="o">=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">teLoc</span> <span class="o">=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">timedSeq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ts</span> <span class="o">&lt;</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">tsIndex</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">dTs</span> <span class="o">=</span> <span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">tsX</span> <span class="o">=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">dTs</span>
            <span class="n">tsY</span> <span class="o">=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">dTs</span>
            <span class="n">tsLoc</span> <span class="o">=</span> <span class="p">[</span><span class="n">tsX</span><span class="p">,</span> <span class="n">tsY</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tsIndex</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">timedSeq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">te</span> <span class="o">&lt;</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">teIndex</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="n">dTe</span> <span class="o">=</span> <span class="p">(</span><span class="n">te</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">teX</span> <span class="o">=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">dTe</span>
                    <span class="n">teY</span> <span class="o">=</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedSeq</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">dTe</span>
                    <span class="n">teLoc</span> <span class="o">=</span> <span class="p">[</span><span class="n">teX</span><span class="p">,</span> <span class="n">teY</span><span class="p">]</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tsIndex</span> <span class="o">==</span> <span class="n">teIndex</span><span class="p">):</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="p">[</span><span class="n">tsLoc</span><span class="p">,</span> <span class="n">teLoc</span><span class="p">]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">tsIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">teIndex</span><span class="p">):</span>
        <span class="n">trace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tsLoc</span><span class="p">)</span>
        <span class="n">trace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">tsIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">trace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">teLoc</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tsLoc</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tsIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">teIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">trace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timedSeq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">trace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">teLoc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">trace</span></div>


<span class="c1"># Loc seq related =============================================================</span>
<div class="viewcode-block" id="locSeqSortPts">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.locSeqSortPts">[docs]</a>
<span class="k">def</span> <span class="nf">locSeqSortPts</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span> <span class="n">pts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span> <span class="n">allowNotIncludeFlag</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="c1"># First, calculate accumulated dist since start for each turning point of locSeq</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sofar</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">sofar</span> <span class="o">+=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
        <span class="n">acc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sofar</span><span class="p">)</span>
    <span class="n">ptHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">notIncludedPts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># 看看每个节点落在哪个区间</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">pts</span><span class="p">:</span>
        <span class="n">isOnSegFlag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># 若和多个线段相交，只考虑第一次相交的情况，否则turnpoint上的始终会被记录两次</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">isPtOnSeg</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])):</span>
                <span class="n">isOnSegFlag</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">addDist</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pt</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">ptHeap</span><span class="p">,</span> <span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">addDist</span><span class="p">,</span> <span class="n">pt</span><span class="p">))</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">isOnSegFlag</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">allowNotIncludeFlag</span><span class="p">):</span>
                <span class="n">notIncludedPts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UnsupportedInputError</span><span class="p">(</span><span class="s2">&quot;ERROR: </span><span class="si">%s</span><span class="s2"> does not belong to given loc sequence&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">pt</span><span class="p">))</span>

    <span class="n">sortedPts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ptHeap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">sortedPts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">ptHeap</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;sortedPts&#39;</span><span class="p">:</span> <span class="n">sortedPts</span><span class="p">,</span>
        <span class="s1">&#39;notIncludedPts&#39;</span><span class="p">:</span> <span class="n">notIncludedPts</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="locSeqSortNodes">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.locSeqSortNodes">[docs]</a>
<span class="k">def</span> <span class="nf">locSeqSortNodes</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">locFieldName</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="n">allowNotIncludeFlag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span> 
    <span class="n">acc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sofar</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">sofar</span> <span class="o">+=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
        <span class="n">acc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sofar</span><span class="p">)</span>
    <span class="n">ptHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">notIncludedNodeIDs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">nodeID</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">isOnSegFlag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">isPtOnSeg</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">nodeID</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])):</span>
                <span class="n">isOnSegFlag</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">addDist</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">nodeID</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">addDist</span><span class="p">,</span> <span class="n">nodeID</span><span class="p">)</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">ptHeap</span><span class="p">,</span> <span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">addDist</span><span class="p">,</span> <span class="n">nodeID</span><span class="p">))</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">isOnSegFlag</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">allowNotIncludeFlag</span><span class="p">):</span>
                <span class="n">notIncludedNodeIDs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UnsupportedInputError</span><span class="p">(</span><span class="s2">&quot;ERROR: </span><span class="si">%s</span><span class="s2"> does not belong to given loc sequence&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">nodeID</span><span class="p">))</span>
    
    <span class="n">sortedNodeIDs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ptHeap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">sortedNodeIDs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">ptHeap</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;sortedNodeIDs&#39;</span><span class="p">:</span> <span class="n">sortedNodeIDs</span><span class="p">,</span>
        <span class="s1">&#39;notIncludedNodeIDs&#39;</span><span class="p">:</span> <span class="n">notIncludedNodeIDs</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="locSeqMileage">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.locSeqMileage">[docs]</a>
<span class="k">def</span> <span class="nf">locSeqMileage</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span> <span class="n">dist</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="nb">float</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;XY&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pt</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a list of lat/lon coordinates, and a traveling mileage, returns the coordinate&quot;&quot;&quot;</span>
    <span class="c1"># Initialize ==============================================================</span>
    <span class="n">inPathFlag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">accDist</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">preLoc</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nextLoc</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Find segment ============================================================</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">==</span> <span class="s1">&#39;LatLon&#39;</span><span class="p">):</span>
            <span class="n">accDist</span> <span class="o">+=</span> <span class="n">distLatLon</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">==</span> <span class="s1">&#39;XY&#39;</span><span class="p">):</span>
            <span class="n">accDist</span> <span class="o">+=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">accDist</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">):</span>
            <span class="n">preLoc</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">nextLoc</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">inPathFlag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">inPathFlag</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">UnsupportedInputError</span><span class="p">(</span><span class="s2">&quot;ERROR: `dist` is longer than the length of `seq`&quot;</span><span class="p">)</span>
    <span class="c1"># Find location on the segment ============================================</span>
    <span class="n">remainDist</span> <span class="o">=</span> <span class="n">accDist</span> <span class="o">-</span> <span class="n">dist</span>
    <span class="n">segDist</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">==</span> <span class="s1">&#39;LatLon&#39;</span><span class="p">):</span>
        <span class="n">segDist</span> <span class="o">=</span> <span class="n">distLatLon</span><span class="p">(</span><span class="n">preLoc</span><span class="p">,</span> <span class="n">nextLoc</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">==</span> <span class="s1">&#39;XY&#39;</span><span class="p">):</span>
        <span class="n">segDist</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">preLoc</span><span class="p">,</span> <span class="n">nextLoc</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">segDist</span> <span class="o">&lt;=</span> <span class="n">CONST_EPSILON</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ZeroDivisionError</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">nextLoc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">remainDist</span> <span class="o">/</span> <span class="n">segDist</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">preLoc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">nextLoc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">nextLoc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">remainDist</span> <span class="o">/</span> <span class="n">segDist</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">preLoc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">nextLoc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>


<span class="c1"># Area calculation ============================================================</span>
<div class="viewcode-block" id="calTriangleAreaEdge">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.calTriangleAreaEdge">[docs]</a>
<span class="k">def</span> <span class="nf">calTriangleAreaEdge</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    
    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">b</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">c</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">c</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">area</span></div>


<div class="viewcode-block" id="calTriangleAreaXY">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.calTriangleAreaXY">[docs]</a>
<span class="k">def</span> <span class="nf">calTriangleAreaXY</span><span class="p">(</span><span class="n">pt1</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">pt2</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">pt3</span><span class="p">:</span> <span class="n">pt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    
    <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt1</span>
    <span class="p">[</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt2</span>
    <span class="p">[</span><span class="n">x3</span><span class="p">,</span> <span class="n">y3</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt3</span>
    <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y3</span> <span class="o">+</span> <span class="n">x3</span> <span class="o">*</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">x1</span> <span class="o">*</span> <span class="n">y2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">x3</span> <span class="o">*</span> <span class="n">y2</span> <span class="o">+</span> <span class="n">x1</span> <span class="o">*</span> <span class="n">y3</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">area</span></div>


<div class="viewcode-block" id="calPolyAreaXY">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.calPolyAreaXY">[docs]</a>
<span class="k">def</span> <span class="nf">calPolyAreaXY</span><span class="p">(</span><span class="n">poly</span><span class="p">:</span> <span class="n">poly</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">lstTriangle</span> <span class="o">=</span> <span class="n">tripy</span><span class="o">.</span><span class="n">earclip</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lstTriangle</span><span class="p">)):</span>
        <span class="n">area</span> <span class="o">+=</span> <span class="n">calTriangleAreaXY</span><span class="p">(</span><span class="n">lstTriangle</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">lstTriangle</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">lstTriangle</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">area</span></div>


<div class="viewcode-block" id="calPolyAreaLatLon">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.calPolyAreaLatLon">[docs]</a>
<span class="k">def</span> <span class="nf">calPolyAreaLatLon</span><span class="p">(</span><span class="n">polyLatLon</span><span class="p">:</span> <span class="n">poly</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the area surrounded by polyLatLon on the Earth&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pyproj</span> <span class="kn">import</span> <span class="n">Geod</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span>

    <span class="c1"># NOTE: shapely is in [lon, lat] format</span>
    <span class="n">rev</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polyLatLon</span><span class="p">:</span>
        <span class="n">rev</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">polygon</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">rev</span><span class="p">)</span>

    <span class="c1"># Using pyproj to calculate</span>
    <span class="c1"># Ref: https://hypc.github.io/2020/03/16/python-geo-area/</span>
    <span class="n">geod</span> <span class="o">=</span> <span class="n">Geod</span><span class="p">(</span><span class="n">ellps</span> <span class="o">=</span> <span class="s2">&quot;WGS84&quot;</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">geod</span><span class="o">.</span><span class="n">geometry_area_perimeter</span><span class="p">(</span><span class="n">polygon</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">area</span></div>


<div class="viewcode-block" id="calPolyPerimeterXY">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.calPolyPerimeterXY">[docs]</a>
<span class="k">def</span> <span class="nf">calPolyPerimeterXY</span><span class="p">(</span><span class="n">poly</span><span class="p">:</span> <span class="n">poly</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">+=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">poly</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">poly</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">p</span></div>


<span class="c1"># Location of points ==========================================================</span>
<div class="viewcode-block" id="headingXY">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.headingXY">[docs]</a>
<span class="k">def</span> <span class="nf">headingXY</span><span class="p">(</span><span class="n">pt1</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">pt2</span><span class="p">:</span> <span class="n">pt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given two points, returns the direction from the first point to the second point</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt1: pt, required</span>
<span class="sd">        The first point</span>
<span class="sd">    pt2: pt, required</span>
<span class="sd">        The second point</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    float</span>
<span class="sd">        The direction from pt1 to pt2, north as 0, clock-wise</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">vDeg</span><span class="p">)</span> <span class="o">=</span> <span class="n">vecXY2Polar</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vDeg</span></div>


<div class="viewcode-block" id="headingLatLon">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.headingLatLon">[docs]</a>
<span class="k">def</span> <span class="nf">headingLatLon</span><span class="p">(</span><span class="n">pt1</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">pt2</span><span class="p">:</span> <span class="n">pt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given current location and a goal location, calculate the heading. North is 0-degrees, clock-wise</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt1: pt, required</span>
<span class="sd">        The first point</span>
<span class="sd">    pt2: pt, required</span>
<span class="sd">        The second point</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    float</span>
<span class="sd">        The direction from pt1 to pt2, north as 0, clock-wise</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Ref: https://github.com/manuelbieh/Geolib/issues/28</span>
    <span class="p">(</span><span class="n">lat1</span><span class="p">,</span> <span class="n">lon1</span><span class="p">)</span> <span class="o">=</span> <span class="n">pt1</span>
    <span class="p">(</span><span class="n">lat2</span><span class="p">,</span> <span class="n">lon2</span><span class="p">)</span> <span class="o">=</span> <span class="n">pt2</span>
    <span class="n">lat1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span>
    <span class="n">lon1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lon1</span><span class="p">)</span>
    <span class="n">lat2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span>
    <span class="n">lon2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lon2</span><span class="p">)</span>
    <span class="n">dLon</span> <span class="o">=</span> <span class="n">lon2</span> <span class="o">-</span> <span class="n">lon1</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dLon</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dLon</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">dLon</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">dLon</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dLon</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">dLon</span><span class="p">)</span>
    <span class="n">tan1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">lat1</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">)</span>
    <span class="n">tan2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">lat2</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tan2</span> <span class="o">/</span> <span class="n">tan1</span><span class="p">)</span>
    <span class="n">deg</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">dLon</span><span class="p">,</span> <span class="n">phi</span><span class="p">))</span> <span class="o">+</span> <span class="mf">360.0</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.0</span>
    <span class="k">return</span> <span class="n">deg</span></div>


<div class="viewcode-block" id="ptInDistXY">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.ptInDistXY">[docs]</a>
<span class="k">def</span> <span class="nf">ptInDistXY</span><span class="p">(</span><span class="n">pt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="nb">float</span><span class="p">,</span> <span class="n">dist</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pt</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A location in distance with given direction.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt: pt, required</span>
<span class="sd">        The origin point</span>
<span class="sd">    direction: float, required</span>
<span class="sd">        The direction from origin point</span>
<span class="sd">    dist: float, required</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pt</span>
<span class="sd">        The new location</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">direction</span><span class="p">))</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">direction</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>


<div class="viewcode-block" id="ptInDistLatLon">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.ptInDistLatLon">[docs]</a>
<span class="k">def</span> <span class="nf">ptInDistLatLon</span><span class="p">(</span><span class="n">pt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="nb">float</span><span class="p">,</span> <span class="n">distMeters</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pt</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A location in distance with given direction in lat/lon.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt: pt, required</span>
<span class="sd">        The origin point</span>
<span class="sd">    direction: float, required</span>
<span class="sd">        The direction from origin point</span>
<span class="sd">    dist: float, required</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pt</span>
<span class="sd">        The new location</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Bearing in degrees: 0 – North, 90 – East, 180 – South, 270 or -90 – West.</span>
    <span class="n">newLoc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">geopy</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">meters</span><span class="o">=</span><span class="n">distMeters</span><span class="p">)</span><span class="o">.</span><span class="n">destination</span><span class="p">(</span><span class="n">point</span><span class="o">=</span><span class="n">pt</span><span class="p">,</span> <span class="n">bearing</span><span class="o">=</span><span class="n">direction</span><span class="p">))[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">newLoc</span></div>


<div class="viewcode-block" id="circleByCenterLatLon">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.circleByCenterLatLon">[docs]</a>
<span class="k">def</span> <span class="nf">circleByCenterLatLon</span><span class="p">(</span><span class="n">center</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="nb">float</span><span class="p">,</span> <span class="n">lod</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">poly</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a circle by the center and a radius. The circle is approximated by a x-gon, e.g., 30-gon polygon.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center: pt, required</span>
<span class="sd">        The center of the circle</span>
<span class="sd">    radius: float, required</span>
<span class="sd">        The radius of the circle</span>
<span class="sd">    lod: int, optional, default as 30</span>
<span class="sd">        Level of details. The circle is approximated as a x-gon. E.g. 30-gon</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    poly</span>
<span class="sd">        A polygon that approximates the circle.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">circle</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lod</span><span class="p">):</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">360</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">lod</span><span class="p">)</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">ptInDistLatLon</span><span class="p">(</span><span class="n">pt</span> <span class="o">=</span> <span class="n">center</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">deg</span><span class="p">,</span> <span class="n">distMeters</span> <span class="o">=</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">circle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">circle</span></div>


<div class="viewcode-block" id="circleByCenterXY">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.circleByCenterXY">[docs]</a>
<span class="k">def</span> <span class="nf">circleByCenterXY</span><span class="p">(</span><span class="n">center</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="nb">float</span><span class="p">,</span> <span class="n">lod</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">poly</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a circle by the center and a radius. The circle is approximated by a x-gon, e.g., 30-gon polygon.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center: pt, required</span>
<span class="sd">        The center of the circle</span>
<span class="sd">    radius: float, required</span>
<span class="sd">        The radius of the circle</span>
<span class="sd">    lod: int, optional, default as 30</span>
<span class="sd">        Level of details. The circle is approximated as a x-gon. E.g. 30-gon</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    poly</span>
<span class="sd">        A polygon that approximates the circle.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">circle</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lod</span><span class="p">):</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">360</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">lod</span><span class="p">)</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">ptInDistXY</span><span class="p">(</span><span class="n">pt</span> <span class="o">=</span> <span class="n">center</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">deg</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">circle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">circle</span></div>


<span class="c1"># Sort nodes ==================================================================</span>
<div class="viewcode-block" id="nodeSeqByDist">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.nodeSeqByDist">[docs]</a>
<span class="k">def</span> <span class="nf">nodeSeqByDist</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">nodeIDs</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="n">locFieldName</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="n">refLoc</span><span class="p">:</span> <span class="n">pt</span><span class="o">|</span><span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">refNodeID</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="nb">str</span><span class="o">|</span><span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="c1"># Define nodeIDs</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">nodeIDs</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nodeIDs</span> <span class="o">==</span> <span class="s1">&#39;All&#39;</span><span class="p">):</span>
            <span class="n">nodeIDs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="n">nodeIDs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># Define refLoc</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">refLoc</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">refNodeID</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: Missing reference location&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">refNodeID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">OutOfRangeError</span><span class="p">(</span><span class="s2">&quot;ERROR: `refNodeID` cannot be found.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">refLoc</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">refNodeID</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">]</span>

    <span class="c1"># Sort distance</span>
    <span class="n">sortedSeq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sortedSeqHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">scaleDist</span><span class="p">(</span><span class="n">loc1</span> <span class="o">=</span> <span class="n">refLoc</span><span class="p">,</span> <span class="n">loc2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">edges</span> <span class="o">=</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">sortedSeqHeap</span><span class="p">,</span> <span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sortedSeqHeap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">sortedSeq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">sortedSeqHeap</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>  

    <span class="k">return</span> <span class="n">sortedSeq</span></div>


<div class="viewcode-block" id="nodeSeqBySweeping">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.nodeSeqBySweeping">[docs]</a>
<span class="k">def</span> <span class="nf">nodeSeqBySweeping</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">nodeIDs</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="n">locFieldName</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="n">refLoc</span><span class="p">:</span> <span class="kc">None</span><span class="o">|</span><span class="n">pt</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">refNodeID</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="nb">str</span><span class="o">|</span><span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">isClockwise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">initDeg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a set of locations, and a center point, gets the sequence from sweeping&quot;&quot;&quot;</span>
    <span class="c1"># Define nodeIDs</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">nodeIDs</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nodeIDs</span> <span class="o">==</span> <span class="s1">&#39;All&#39;</span><span class="p">):</span>
            <span class="n">nodeIDs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="n">nodeIDs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># Initialize centroid</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">refLoc</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">lstNodeLoc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
            <span class="n">lstNodeLoc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">refLoc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">centroid</span><span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">MultiPoint</span><span class="p">(</span><span class="n">points</span> <span class="o">=</span> <span class="n">lstNodeLoc</span><span class="p">)))</span>

    <span class="c1"># Initialize heap</span>
    <span class="n">degHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">refLocNodes</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Build heap</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">refLoc</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
        <span class="c1"># If the nodes are too close, separate it/them</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">CONST_EPSILON</span><span class="p">):</span>
            <span class="n">refLocNodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">refLoc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">refLoc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">deg</span><span class="p">)</span> <span class="o">=</span> <span class="n">vecXY2Polar</span><span class="p">((</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">))</span>
            <span class="c1"># Calculate angles</span>
            <span class="n">evalDeg</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">isClockwise</span><span class="p">):</span>
                <span class="n">evalDeg</span> <span class="o">=</span> <span class="n">deg</span> <span class="o">-</span> <span class="n">initDeg</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">evalDeg</span> <span class="o">=</span> <span class="n">initDeg</span> <span class="o">-</span> <span class="n">deg</span>
            <span class="k">while</span><span class="p">(</span><span class="n">evalDeg</span> <span class="o">&gt;</span> <span class="mi">360</span><span class="p">):</span>
                <span class="n">evalDeg</span> <span class="o">-=</span> <span class="mi">360</span>
            <span class="k">while</span><span class="p">(</span><span class="n">evalDeg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">evalDeg</span> <span class="o">+=</span> <span class="mi">360</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">degHeap</span><span class="p">,</span> <span class="p">(</span><span class="n">evalDeg</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

    <span class="c1"># Sweep</span>
    <span class="n">sweepSeq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">degHeap</span><span class="p">)):</span>
        <span class="n">sweepSeq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">degHeap</span><span class="p">)[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">sweepSeq</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">refLocNodes</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sweepSeq</span></div>


<div class="viewcode-block" id="nodesInIsochrone">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.nodesInIsochrone">[docs]</a>
<span class="k">def</span> <span class="nf">nodesInIsochrone</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">nodeIDs</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="n">locFieldName</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="n">refLoc</span><span class="p">:</span> <span class="n">pt</span><span class="o">|</span><span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">refNodeID</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="nb">str</span><span class="o">|</span><span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">isoRange</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sortFlag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span> 
    <span class="c1"># FIXME: Need an algorithm to filter out locations that are clearly too far from refLoc</span>
    <span class="c1"># Define nodeIDs</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">nodeIDs</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nodeIDs</span> <span class="o">==</span> <span class="s1">&#39;All&#39;</span><span class="p">):</span>
            <span class="n">nodeIDs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="n">nodeIDs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># Define refLoc</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">refLoc</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">refNodeID</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: Missing reference location&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">refNodeID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">OutOfRangeError</span><span class="p">(</span><span class="s2">&quot;ERROR: `refNodeID` cannot be found.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">refLoc</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">refNodeID</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">]</span>

    <span class="c1"># Sort distance</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isoRange</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: Missing required field `isoRange`.&quot;</span><span class="p">)</span>
    <span class="n">nearSet</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nearest</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">nearestDist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sortFlag</span><span class="p">):</span>        
        <span class="n">nearSetHeap</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">scaleDist</span><span class="p">(</span><span class="n">loc1</span> <span class="o">=</span> <span class="n">refLoc</span><span class="p">,</span> <span class="n">loc2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">edges</span> <span class="o">=</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">isoRange</span><span class="p">):</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">nearSetHeap</span><span class="p">,</span> <span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nearSetHeap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">nearSet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">nearSetHeap</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">nearest</span> <span class="o">=</span> <span class="n">nearSet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">scaleDist</span><span class="p">(</span><span class="n">loc1</span> <span class="o">=</span> <span class="n">refLoc</span><span class="p">,</span> <span class="n">loc2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">edges</span> <span class="o">=</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">isoRange</span><span class="p">):</span>
                <span class="n">nearSet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">nearestDist</span><span class="p">):</span>
                <span class="n">nearest</span> <span class="o">=</span> <span class="n">n</span>
                <span class="n">nearestDist</span> <span class="o">=</span> <span class="n">dist</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;nearSet&#39;</span><span class="p">:</span> <span class="n">nearSet</span><span class="p">,</span>
        <span class="s1">&#39;nearest&#39;</span><span class="p">:</span> <span class="n">nearest</span>
    <span class="p">}</span></div>


<span class="c1"># Create distance matrix ======================================================</span>
<div class="viewcode-block" id="matrixDist">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.matrixDist">[docs]</a>
<span class="k">def</span> <span class="nf">matrixDist</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">locFieldName</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="n">nodeIDs</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a `nodes` dictionary, returns the traveling matrix between nodes</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    nodes: dict, required</span>
<span class="sd">        A `nodes`dictionary with location information</span>
<span class="sd">    locFieldName: str, optional, default as &#39;loc&#39;</span>
<span class="sd">        The key in nodes dictionary to indicate the locations</span>
<span class="sd">    nodeIDs: list of int|str, or &#39;All&#39;, optional, default as &#39;All&#39;</span>
<span class="sd">        A list of nodes in `nodes` that needs to be considered, other nodes will be ignored</span>
<span class="sd">    edges: str, optional, default as &#39;Euclidean&#39;</span>
<span class="sd">        The methods for the calculation of distances between nodes. Options and required additional information are as follows:</span>

<span class="sd">        1) (default) &#39;Euclidean&#39;, using Euclidean distance, no additional information needed</span>
<span class="sd">        2) &#39;EuclideanBarrier&#39;, using Euclidean distance, if `polys` is provided, the path between nodes will consider them as barriers and by pass those areas.</span>
<span class="sd">            - polys: list of poly, the polygons to be considered as barriers</span>
<span class="sd">        3) &#39;LatLon&#39;, calculate distances by lat/lon, no additional information needed</span>
<span class="sd">            - distUnit: str, the unit of distance, default as &#39;meter&#39;</span>
<span class="sd">        4) &#39;ManhattenXY&#39;, calculate distance by Manhatten distance            </span>
<span class="sd">        5) &#39;Dictionary&#39;, directly provide the travel matrix</span>
<span class="sd">            - tau: the traveling matrix</span>
<span class="sd">        6) &#39;Grid&#39;, traveling on a grid with barriers, usually used in warehouses</span>
<span class="sd">            - column: number of columns</span>
<span class="sd">            - row: number of rows</span>
<span class="sd">            - barrier: a list of coordinates on the grid indicating no-entrance</span>
<span class="sd">    **kwargs: optional</span>
<span class="sd">        Provide additional inputs for different `edges` options</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    tuple</span>
<span class="sd">        Two dictionaries, the first one is the travel matrix, index by (nodeID1, nodeID2), the second one is the dictionary for path between start and end locations (useful for &#39;EuclideanBarrier&#39;).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define tau</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">nodeIDs</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nodeIDs</span> <span class="o">==</span> <span class="s1">&#39;All&#39;</span><span class="p">):</span>
            <span class="n">nodeIDs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="n">nodeIDs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">):</span>
        <span class="n">tau</span><span class="p">,</span> <span class="n">pathLoc</span> <span class="o">=</span> <span class="n">_matrixDistEuclideanXY</span><span class="p">(</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">,</span> 
            <span class="n">nodeIDs</span> <span class="o">=</span> <span class="n">nodeIDs</span><span class="p">,</span> 
            <span class="n">locFieldName</span> <span class="o">=</span> <span class="n">locFieldName</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="s1">&#39;EuclideanBarrier&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;polys&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;polys&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;WARNING: No barrier provided.&quot;</span><span class="p">)</span>
            <span class="n">tau</span><span class="p">,</span> <span class="n">pathLoc</span> <span class="o">=</span> <span class="n">_matrixDistEuclideanXY</span><span class="p">(</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">,</span> 
                <span class="n">nodeIDs</span> <span class="o">=</span> <span class="n">nodeIDs</span><span class="p">,</span> 
                <span class="n">locFieldName</span> <span class="o">=</span> <span class="n">locFieldName</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tau</span><span class="p">,</span> <span class="n">pathLoc</span> <span class="o">=</span> <span class="n">_matrixDistBtwPolysXY</span><span class="p">(</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">,</span> 
                <span class="n">nodeIDs</span> <span class="o">=</span> <span class="n">nodeIDs</span><span class="p">,</span> 
                <span class="n">polys</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;polys&#39;</span><span class="p">],</span> 
                <span class="n">locFieldName</span> <span class="o">=</span> <span class="n">locFieldName</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="s1">&#39;LatLon&#39;</span><span class="p">):</span>
        <span class="n">distUnit</span> <span class="o">=</span> <span class="s1">&#39;meter&#39;</span> <span class="k">if</span> <span class="s1">&#39;distUnit&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;distUnit&#39;</span><span class="p">]</span>
        <span class="n">tau</span><span class="p">,</span> <span class="n">pathLoc</span> <span class="o">=</span> <span class="n">_matrixDistLatLon</span><span class="p">(</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">,</span> 
            <span class="n">nodeIDs</span> <span class="o">=</span> <span class="n">nodeIDs</span><span class="p">,</span> 
            <span class="n">distUnit</span> <span class="o">=</span> <span class="n">distUnit</span><span class="p">,</span>
            <span class="n">locFieldName</span> <span class="o">=</span> <span class="n">locFieldName</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="s1">&#39;Manhatten&#39;</span><span class="p">):</span>
        <span class="n">tau</span><span class="p">,</span> <span class="n">pathLoc</span> <span class="o">=</span> <span class="n">_matrixDistManhattenXY</span><span class="p">(</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">,</span> 
            <span class="n">nodeIDs</span> <span class="o">=</span> <span class="n">nodeIDs</span><span class="p">,</span> 
            <span class="n">locFieldName</span> <span class="o">=</span> <span class="n">locFieldName</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="s1">&#39;Dictionary&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;tau&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;tau&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: &#39;tau&#39; is not specified&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;tau&#39;</span><span class="p">]:</span>
            <span class="n">tau</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;tau&#39;</span><span class="p">][</span><span class="n">p</span><span class="p">]</span>
            <span class="n">pathLoc</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;path&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">locFieldName</span><span class="p">]]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="s1">&#39;Grid&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;grid&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: &#39;grid&#39; is not specified&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;column&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="s1">&#39;row&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;&#39;column&#39; and &#39;row&#39; need to be specified in &#39;grid&#39;&quot;</span><span class="p">)</span>
        <span class="n">tau</span><span class="p">,</span> <span class="n">pathLoc</span> <span class="o">=</span> <span class="n">_matrixDistGrid</span><span class="p">(</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">,</span> 
            <span class="n">nodeIDs</span> <span class="o">=</span> <span class="n">nodeIDs</span><span class="p">,</span> 
            <span class="n">grids</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">],</span> 
            <span class="n">locFieldName</span> <span class="o">=</span> <span class="n">locFieldName</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnsupportedInputError</span><span class="p">(</span><span class="n">ERROR_MISSING_EDGES</span><span class="p">)</span>        

    <span class="k">return</span> <span class="n">tau</span><span class="p">,</span> <span class="n">pathLoc</span></div>


<span class="k">def</span> <span class="nf">_matrixDistEuclideanXY</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">nodeIDs</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">locFieldName</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span><span class="p">):</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">])</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">]]</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">tau</span><span class="p">,</span> <span class="n">pathLoc</span>

<span class="k">def</span> <span class="nf">_matrixDistManhattenXY</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">nodeIDs</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">locFieldName</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span><span class="p">):</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">distManhattenXY</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">])</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]))]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">tau</span><span class="p">,</span> <span class="n">pathLoc</span>

<span class="k">def</span> <span class="nf">_matrixDistLatLon</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">nodeIDs</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">distUnit</span> <span class="o">=</span> <span class="s1">&#39;meter&#39;</span><span class="p">,</span> <span class="n">locFieldName</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span><span class="p">):</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">distLatLon</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">distUnit</span><span class="p">)</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">]]</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">tau</span><span class="p">,</span> <span class="n">pathLoc</span>

<span class="k">def</span> <span class="nf">_matrixDistGrid</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">nodeIDs</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">locFieldName</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span><span class="p">):</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">distOnGrid</span><span class="p">(</span><span class="n">pt1</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">pt2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">)</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]))]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">tau</span><span class="p">,</span> <span class="n">pathLoc</span>

<span class="k">def</span> <span class="nf">_matrixDistBtwPolysXY</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">nodeIDs</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">polys</span><span class="p">:</span> <span class="n">polys</span><span class="p">,</span> <span class="n">polyVG</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">locFieldName</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span><span class="p">):</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">polyVG</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">polyVG</span> <span class="o">=</span> <span class="n">polysVisibleGraph</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">distBtwPolysXY</span><span class="p">(</span><span class="n">pt1</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">pt2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">polys</span> <span class="o">=</span> <span class="n">polys</span><span class="p">,</span> <span class="n">polyVG</span> <span class="o">=</span> <span class="n">polyVG</span><span class="p">)</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]))]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span>
                <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">pathLoc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">tau</span><span class="p">,</span> <span class="n">pathLoc</span>

<div class="viewcode-block" id="vectorDist">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.vectorDist">[docs]</a>
<span class="k">def</span> <span class="nf">vectorDist</span><span class="p">(</span><span class="n">loc</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">locFieldName</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="n">nodeIDs</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;All&#39;</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a location and a `nodes` dictionary, returns the traveling distance and path between the location to each node.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loc: pt, required</span>
<span class="sd">        Origin/destination location.</span>
<span class="sd">    nodes: dict, required</span>
<span class="sd">        A `nodes`dictionary with location information. See :ref:`nodes` for reference.</span>
<span class="sd">    locFieldName: str, optional, default as &#39;loc&#39;</span>
<span class="sd">        The key in nodes dictionary to indicate the locations</span>
<span class="sd">    nodeIDs: list of int|str, or &#39;All&#39;, optional, default as &#39;All&#39;</span>
<span class="sd">        A list of nodes in `nodes` that needs to be considered, other nodes will be ignored</span>
<span class="sd">    edges: str, optional, default as &#39;Euclidean&#39;</span>
<span class="sd">        The methods for the calculation of distances between nodes. Options and required additional information are referred to :func:`~vrpSolver.geometry.matrixDist()`.</span>
<span class="sd">    **kwargs: optional</span>
<span class="sd">        Provide additional inputs for different `edges` options</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    tuple</span>
<span class="sd">        tau, revTau, pathLoc, revPathLoc. Four dictionaries, the first one is the travel distance from loc to each node index by nodeID, the second the travel distance from each node back to loc. The third and fourth dictionaries are the corresponded path.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define tau</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">revTau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">revPathLoc</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">nodeIDs</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nodeIDs</span> <span class="o">==</span> <span class="s1">&#39;All&#39;</span><span class="p">):</span>
            <span class="n">nodeIDs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="n">nodeIDs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">):</span>
        <span class="n">tau</span><span class="p">,</span> <span class="n">revTau</span><span class="p">,</span> <span class="n">pathLoc</span><span class="p">,</span> <span class="n">revPath</span> <span class="o">=</span> <span class="n">_vectorDistEuclideanXY</span><span class="p">(</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span><span class="p">,</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">,</span> 
            <span class="n">nodeIDs</span> <span class="o">=</span> <span class="n">nodeIDs</span><span class="p">,</span> 
            <span class="n">locFieldName</span> <span class="o">=</span> <span class="n">locFieldName</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="s1">&#39;EuclideanBarrier&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;polys&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;polys&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;WARNING: No barrier provided.&quot;</span><span class="p">)</span>
            <span class="n">tau</span><span class="p">,</span> <span class="n">revTau</span><span class="p">,</span> <span class="n">pathLoc</span><span class="p">,</span> <span class="n">revPath</span> <span class="o">=</span> <span class="n">_vectorDistEuclideanXY</span><span class="p">(</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span><span class="p">,</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">,</span> 
                <span class="n">nodeIDs</span> <span class="o">=</span> <span class="n">nodeIDs</span><span class="p">,</span> 
                <span class="n">locFieldName</span> <span class="o">=</span> <span class="n">locFieldName</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tau</span><span class="p">,</span> <span class="n">revTau</span><span class="p">,</span> <span class="n">pathLoc</span><span class="p">,</span> <span class="n">revPath</span> <span class="o">=</span> <span class="n">_vectorDistBtwPolysXY</span><span class="p">(</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span><span class="p">,</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">,</span> 
                <span class="n">nodeIDs</span> <span class="o">=</span> <span class="n">nodeIDs</span><span class="p">,</span> 
                <span class="n">polys</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;polys&#39;</span><span class="p">],</span> 
                <span class="n">locFieldName</span> <span class="o">=</span> <span class="n">locFieldName</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="s1">&#39;LatLon&#39;</span><span class="p">):</span>
        <span class="n">tau</span><span class="p">,</span> <span class="n">revTau</span><span class="p">,</span> <span class="n">pathLoc</span><span class="p">,</span> <span class="n">revPath</span> <span class="o">=</span> <span class="n">_vectorDistLatLon</span><span class="p">(</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span><span class="p">,</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">,</span> 
            <span class="n">nodeIDs</span> <span class="o">=</span> <span class="n">nodeIDs</span><span class="p">,</span> 
            <span class="n">locFieldName</span> <span class="o">=</span> <span class="n">locFieldName</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="s1">&#39;Manhatten&#39;</span><span class="p">):</span>
        <span class="n">tau</span><span class="p">,</span> <span class="n">revTau</span><span class="p">,</span> <span class="n">pathLoc</span><span class="p">,</span> <span class="n">revPath</span> <span class="o">=</span> <span class="n">_vectorDistManhattenXY</span><span class="p">(</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span><span class="p">,</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">,</span> 
            <span class="n">nodeIDs</span> <span class="o">=</span> <span class="n">nodeIDs</span><span class="p">,</span> 
            <span class="n">locFieldName</span> <span class="o">=</span> <span class="n">locFieldName</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="s1">&#39;Grid&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;grid&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;&#39;grid&#39; is not specified&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;column&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="s1">&#39;row&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;&#39;column&#39; and &#39;row&#39; need to be specified in &#39;grid&#39;&quot;</span><span class="p">)</span>
        <span class="n">tau</span><span class="p">,</span> <span class="n">revTau</span><span class="p">,</span> <span class="n">pathLoc</span><span class="p">,</span> <span class="n">revPath</span> <span class="o">=</span> <span class="n">_vectorDistGrid</span><span class="p">(</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span><span class="p">,</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">,</span> 
            <span class="n">nodeIDs</span> <span class="o">=</span> <span class="n">nodeIDs</span><span class="p">,</span> 
            <span class="n">grids</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">],</span> 
            <span class="n">locFieldName</span> <span class="o">=</span> <span class="n">locFieldName</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnsupportedInputError</span><span class="p">(</span><span class="n">ERROR_MISSING_EDGES</span><span class="p">)</span>        

    <span class="k">return</span> <span class="n">tau</span><span class="p">,</span> <span class="n">revTau</span><span class="p">,</span> <span class="n">pathLoc</span><span class="p">,</span> <span class="n">revPathLoc</span></div>


<span class="k">def</span> <span class="nf">_vectorDistEuclideanXY</span><span class="p">(</span><span class="n">loc</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">nodeIDs</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">speed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">locFieldName</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span><span class="p">):</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">revTau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">revPathLoc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">])</span>
        <span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">speed</span>
        <span class="n">revTau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">speed</span>
        <span class="n">pathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc</span><span class="p">,</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">]]</span>
        <span class="n">revPathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">loc</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">tau</span><span class="p">,</span> <span class="n">revTau</span><span class="p">,</span> <span class="n">pathLoc</span><span class="p">,</span> <span class="n">revPathLoc</span>

<span class="k">def</span> <span class="nf">_vectorDistManhattenXY</span><span class="p">(</span><span class="n">loc</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">nodeIDs</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">speed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">locFieldName</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span><span class="p">):</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">revTau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">revPathLoc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">distManhattenXY</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">])</span>
        <span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">speed</span>
        <span class="n">revTau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">speed</span>
        <span class="n">pathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span>
        <span class="n">revPathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]))]</span>
    <span class="k">return</span> <span class="n">tau</span><span class="p">,</span> <span class="n">revTau</span><span class="p">,</span> <span class="n">pathLoc</span><span class="p">,</span> <span class="n">revPathLoc</span>

<span class="k">def</span> <span class="nf">_vectorDistLatLon</span><span class="p">(</span><span class="n">loc</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">nodeIDs</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">distUnit</span> <span class="o">=</span> <span class="s1">&#39;meter&#39;</span><span class="p">,</span> <span class="n">speed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">locFieldName</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span><span class="p">):</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">revTau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">revPathLoc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">distLatLon</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">distUnit</span><span class="p">)</span>
        <span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">speed</span>
        <span class="n">revTau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">speed</span>
        <span class="n">pathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc</span><span class="p">,</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">]]</span>
        <span class="n">revPathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">loc</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">tau</span><span class="p">,</span> <span class="n">revTau</span><span class="p">,</span> <span class="n">pathLoc</span><span class="p">,</span> <span class="n">revPathLoc</span>

<span class="k">def</span> <span class="nf">_vectorDistGrid</span><span class="p">(</span><span class="n">loc</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">nodeIDs</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">locFieldName</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span><span class="p">):</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">revTau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">revPathLoc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">distOnGrid</span><span class="p">(</span><span class="n">pt1</span> <span class="o">=</span> <span class="n">loc</span><span class="p">,</span> <span class="n">pt2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">)</span>
        <span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">speed</span>
        <span class="n">revTau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">speed</span>
        <span class="n">pathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span>
        <span class="n">revPathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]))]</span>
    <span class="k">return</span> <span class="n">tau</span><span class="p">,</span> <span class="n">revTau</span><span class="p">,</span> <span class="n">pathLoc</span><span class="p">,</span> <span class="n">revPathLoc</span>

<span class="k">def</span> <span class="nf">_vectorDistBtwPolysXY</span><span class="p">(</span><span class="n">loc</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">nodeIDs</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">polys</span><span class="p">:</span> <span class="n">polys</span><span class="p">,</span> <span class="n">polyVG</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">locFieldName</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span><span class="p">):</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">revTau</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">revPathLoc</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">polyVG</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">polyVG</span> <span class="o">=</span> <span class="n">polysVisibleGraph</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodeIDs</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">distBtwPolysXY</span><span class="p">(</span><span class="n">pt1</span> <span class="o">=</span> <span class="n">loc</span><span class="p">,</span> <span class="n">pt2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">locFieldName</span><span class="p">],</span> <span class="n">polys</span> <span class="o">=</span> <span class="n">polys</span><span class="p">,</span> <span class="n">polyVG</span> <span class="o">=</span> <span class="n">polyVG</span><span class="p">)</span>
        <span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">speed</span>
        <span class="n">revTau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">speed</span>
        <span class="n">pathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span>
        <span class="n">revPathLoc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]))]</span>
    <span class="k">return</span> <span class="n">tau</span><span class="p">,</span> <span class="n">revTau</span><span class="p">,</span> <span class="n">pathLoc</span><span class="p">,</span> <span class="n">revPathLoc</span>

<div class="viewcode-block" id="scaleDist">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.scaleDist">[docs]</a>
<span class="k">def</span> <span class="nf">scaleDist</span><span class="p">(</span><span class="n">loc1</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">loc2</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a two locations, returns the traveling distance and path between locations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loc1: pt, required</span>
<span class="sd">        The first location.</span>
<span class="sd">    loc2: pt, required</span>
<span class="sd">        The second location.</span>
<span class="sd">    edges: str, optional, default as &#39;Euclidean&#39;</span>
<span class="sd">        The methods for the calculation of distances between nodes. Options and required additional information are referred to :func:`~vrpSolver.geometry.matrixDist()`.</span>
<span class="sd">    **kwargs: optional</span>
<span class="sd">        Provide additional inputs for different `edges` options</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    dict</span>
<span class="sd">        tau, revTau, pathLoc, revPathLoc. Four keys, the first one is the travel distance from loc to each node index by nodeID, the second the travel distance from each node back to loc. The third and fourth dictionaries are the corresponded path.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define tau</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">revDist</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">revPathLoc</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
        <span class="n">revDist</span> <span class="o">=</span> <span class="n">dist</span>
        <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span><span class="p">]</span>
        <span class="n">revPathLoc</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc2</span><span class="p">,</span> <span class="n">loc1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="s1">&#39;EuclideanBarrier&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;polys&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;polys&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;WARNING: No barrier provided.&quot;</span><span class="p">)</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
            <span class="n">revDist</span> <span class="o">=</span> <span class="n">dist</span>
            <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span><span class="p">]</span>
            <span class="n">revPathLoc</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc2</span><span class="p">,</span> <span class="n">loc1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">distBtwPolysXY</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;polys&#39;</span><span class="p">])</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
            <span class="n">revDist</span> <span class="o">=</span> <span class="n">dist</span>
            <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]]</span>
            <span class="n">revPathLoc</span> <span class="o">=</span> <span class="p">[</span><span class="n">pathLoc</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pathLoc</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pathLoc</span><span class="p">))]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="s1">&#39;LatLon&#39;</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">distLatLon</span><span class="p">(</span><span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
        <span class="n">revDist</span> <span class="o">=</span> <span class="n">dist</span>
        <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span><span class="p">]</span>
        <span class="n">revPathLoc</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc2</span><span class="p">,</span> <span class="n">loc1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="s1">&#39;Manhatten&#39;</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">distManhattenXY</span><span class="p">(</span><span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
        <span class="n">revDist</span> <span class="o">=</span> <span class="n">dist</span>
        <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc1</span><span class="p">,</span> <span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">loc2</span><span class="p">]</span>
        <span class="n">revPathLoc</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc2</span><span class="p">,</span> <span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">loc1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="s1">&#39;Grid&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;grid&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;&#39;grid&#39; is not specified&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;column&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="s1">&#39;row&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;&#39;column&#39; and &#39;row&#39; need to be specified in &#39;grid&#39;&quot;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">distOnGrid</span><span class="p">(</span><span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">])</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
        <span class="n">revDist</span> <span class="o">=</span> <span class="n">dist</span>
        <span class="n">pathLoc</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]]</span>
        <span class="n">revPathLoc</span> <span class="o">=</span> <span class="p">[</span><span class="n">pathLoc</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pathLoc</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pathLoc</span><span class="p">))]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnsupportedInputError</span><span class="p">(</span><span class="n">ERROR_MISSING_EDGES</span><span class="p">)</span>        

    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="n">dist</span><span class="p">,</span>
        <span class="s1">&#39;revDist&#39;</span><span class="p">:</span> <span class="n">revDist</span><span class="p">,</span>
        <span class="s1">&#39;pathLoc&#39;</span><span class="p">:</span> <span class="n">pathLoc</span><span class="p">,</span>
        <span class="s1">&#39;revPathLoc&#39;</span><span class="p">:</span> <span class="n">revPathLoc</span>
    <span class="p">}</span></div>


<span class="c1"># Distance calculation ========================================================</span>
<div class="viewcode-block" id="distEuclideanXY">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.distEuclideanXY">[docs]</a>
<span class="k">def</span> <span class="nf">distEuclideanXY</span><span class="p">(</span><span class="n">pt1</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">pt2</span><span class="p">:</span> <span class="n">pt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gives a Euclidean distance based on two coords.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt1: pt, required</span>
<span class="sd">        The first location</span>
<span class="sd">    pt2: pt, required</span>
<span class="sd">        The second location</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary, with the distance in &#39;dist&#39;, and the path in &#39;path&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
        <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">]</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="distManhattenXY">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.distManhattenXY">[docs]</a>
<span class="k">def</span> <span class="nf">distManhattenXY</span><span class="p">(</span><span class="n">pt1</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">pt2</span><span class="p">:</span> <span class="n">pt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gives a Manhatten distance based on two coords.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt1: pt, required</span>
<span class="sd">        The first location</span>
<span class="sd">    pt2: pt, required</span>
<span class="sd">        The second location</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary, with the distance in &#39;dist&#39;, and the path in &#39;path&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">pt1</span><span class="p">,</span> <span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">pt2</span><span class="p">]</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="distBtwPolysXY">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.distBtwPolysXY">[docs]</a>
<span class="k">def</span> <span class="nf">distBtwPolysXY</span><span class="p">(</span><span class="n">pt1</span><span class="p">:</span><span class="n">pt</span><span class="p">,</span> <span class="n">pt2</span><span class="p">:</span><span class="n">pt</span><span class="p">,</span> <span class="n">polys</span><span class="p">:</span><span class="n">polys</span><span class="p">,</span> <span class="n">polyVG</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gives a Manhatten distance based on two coords.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt1: pt, required</span>
<span class="sd">        The first location</span>
<span class="sd">    pt2: pt, required</span>
<span class="sd">        The second location</span>
<span class="sd">    polys: polys, required</span>
<span class="sd">        The polygons as barriers.</span>
<span class="sd">    polyVG: dict, optional, default as None</span>
<span class="sd">        The pre-calculated visual-graph using :func:`~vrpSolver.polysVisibleGraph()`. To avoid repeated calculation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary, with the distance in &#39;dist&#39;, and the path in &#39;path&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Reference: Computational Geometry: Algorithms and Applications Third Edition</span>
    <span class="c1"># By Mark de Berg et al. Page 326 - 330</span>
    <span class="c1"># With some modifications</span>

    <span class="c1"># First check if start pt or end pt is in one of the polygons =============</span>
    <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isPtInPoly</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">interiorOnly</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">OutOfRangeError</span><span class="p">(</span><span class="s2">&quot;Point (</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) is inside `polys` when it is not suppose to.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isPtInPoly</span><span class="p">(</span><span class="n">pt2</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">interiorOnly</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">OutOfRangeError</span><span class="p">(</span><span class="s2">&quot;Point (</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) is inside `polys` when it is not suppose to.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># Quick checkout ==========================================================</span>
    <span class="n">visibleDirectly</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isSegIntPoly</span><span class="p">([</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">],</span> <span class="n">poly</span><span class="p">)):</span>
            <span class="n">visibleDirectly</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">visibleDirectly</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">],</span>
            <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">]</span>
        <span class="p">}</span>

    <span class="c1"># Create visible graph for polys ==========================================</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">polyVG</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>      
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)):</span>
            <span class="n">polys</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">polys</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">p</span><span class="p">]))</span> <span class="k">if</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">polys</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">CONST_EPSILON</span><span class="p">]</span>
        <span class="n">polyVG</span> <span class="o">=</span> <span class="n">polysVisibleGraph</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>

    <span class="c1"># Create a visible graph ==================================================</span>
    <span class="c1"># NOTE: startPt可视的vertices将不需要测试是不是相互之间可视，同样地，可视endPt的vertices之间也不需要可视</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polyVG</span><span class="p">:</span>
        <span class="n">vertices</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">polyVG</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span>
            <span class="s1">&#39;visible&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">polyVG</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="s1">&#39;visible&#39;</span><span class="p">]]</span>
        <span class="p">}</span>
    <span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">pt1</span><span class="p">,</span> <span class="s1">&#39;visible&#39;</span><span class="p">:</span> <span class="p">[]}</span>
    <span class="n">Ws</span> <span class="o">=</span> <span class="n">_visPtAmongPolys</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">polys</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">pt1</span><span class="p">,</span> <span class="s1">&#39;visible&#39;</span><span class="p">:</span> <span class="p">[]}})</span>
    <span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">][</span><span class="s1">&#39;visible&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ws</span>
    <span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">pt2</span><span class="p">,</span> <span class="s1">&#39;visible&#39;</span><span class="p">:</span> <span class="p">[]}</span>
    <span class="n">We</span> <span class="o">=</span> <span class="n">_visPtAmongPolys</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="n">polys</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">pt2</span><span class="p">,</span> <span class="s1">&#39;visible&#39;</span><span class="p">:</span> <span class="p">[]}})</span>
    <span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">][</span><span class="s1">&#39;visible&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">We</span>

    <span class="c1"># Find shortest path ======================================================</span>
    <span class="n">vg</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
        <span class="n">vg</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;visible&#39;</span><span class="p">]:</span>
            <span class="n">vg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">])</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path</span><span class="p">(</span><span class="n">vg</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">)</span>

    <span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">+=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;loc&#39;</span><span class="p">])[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="n">dist</span><span class="p">,</span>
        <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[</span><span class="n">wp</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">]</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="distLatLon">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.distLatLon">[docs]</a>
<span class="k">def</span> <span class="nf">distLatLon</span><span class="p">(</span><span class="n">pt1</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">pt2</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">distUnit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;meter&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gives a distance based on two lat/lon coords.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt1: pt, required</span>
<span class="sd">        The first location</span>
<span class="sd">    pt2: pt, required</span>
<span class="sd">        The second location</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary, with the distance in &#39;dist&#39;, and the path in &#39;path&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Get radius as in distUnit ===============================================</span>
    <span class="n">R</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">distUnit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mile&#39;</span><span class="p">,</span> <span class="s1">&#39;mi&#39;</span><span class="p">]):</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">CONST_EARTH_RADIUS_MILES</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">distUnit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;meter&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">]):</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">CONST_EARTH_RADIUS_METERS</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">distUnit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;kilometer&#39;</span><span class="p">,</span> <span class="s1">&#39;km&#39;</span><span class="p">]):</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">CONST_EARTH_RADIUS_METERS</span> <span class="o">/</span> <span class="mi">1000</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnsupportedInputError</span><span class="p">(</span><span class="s2">&quot;ERROR: Unrecognized distance unit, options are &#39;mile&#39;, &#39;meter&#39;, &#39;kilometer&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># Calculate distance ======================================================</span>
    <span class="p">(</span><span class="n">lat1</span><span class="p">,</span> <span class="n">lon1</span><span class="p">)</span> <span class="o">=</span> <span class="n">pt1</span>
    <span class="p">(</span><span class="n">lat2</span><span class="p">,</span> <span class="n">lon2</span><span class="p">)</span> <span class="o">=</span> <span class="n">pt2</span>
    <span class="n">phi1</span><span class="p">,</span> <span class="n">phi2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat1</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> 
    <span class="n">dphi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat2</span> <span class="o">-</span> <span class="n">lat1</span><span class="p">)</span>
    <span class="n">dlambda</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lon2</span> <span class="o">-</span> <span class="n">lon1</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dphi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi1</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi2</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlambda</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">R</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">)),</span>
        <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">]</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="distOnGrid">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.distOnGrid">[docs]</a>
<span class="k">def</span> <span class="nf">distOnGrid</span><span class="p">(</span><span class="n">pt1</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">pt2</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">barriers</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">algo</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;A*&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given two coordinates on the grid, finds the &#39;shortest&#39; path to travel</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    pt1: pt, required</span>
<span class="sd">        Starting location on the grid</span>
<span class="sd">    pt2: pt, required</span>
<span class="sd">        Ending location on the grid </span>
<span class="sd">    column: int, required</span>
<span class="sd">        Number of columns</span>
<span class="sd">    row: int, required</span>
<span class="sd">        Number of rows</span>
<span class="sd">    barriers: list[pt], optional, default as []</span>
<span class="sd">        A list of coordinates as barriers on the grid.</span>
<span class="sd">    algo: dict, required, default as &#39;A*&#39;</span>
<span class="sd">        The algorithm configuration. For example</span>

<span class="sd">        1) A*, use the A star algorithm, additional information needed is as follows</span>
<span class="sd">            - measure: str, optional, default as &#39;Manhatten&#39;            </span>
<span class="sd">    **kwargs: optional</span>
<span class="sd">        Provide additional inputs for different `algo` options</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary, with the distance in &#39;dist&#39;, and the path in &#39;path&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">algo</span> <span class="o">==</span> <span class="s1">&#39;A*&#39;</span><span class="p">):</span>
        <span class="n">measure</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;measure&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;measure&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Manhatten&#39;</span><span class="p">,</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">]):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;WARNING: Set distance measurement to be default as &#39;Manhatten&quot;</span><span class="p">)</span>
            <span class="n">measure</span> <span class="o">=</span> <span class="s1">&#39;Manhatten&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">measure</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;measure&#39;</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_distOnGridAStar</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">barriers</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">measure</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnsupportedInputError</span><span class="p">(</span><span class="s2">&quot;Error: Incorrect or not available grid path finding option!&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>


<span class="k">def</span> <span class="nf">_distOnGridAStar</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">barriers</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">distMeasure</span><span class="p">):</span>
    <span class="c1"># Heuristic measure ==================================================-</span>
    <span class="k">def</span> <span class="nf">_calManhattenDist</span><span class="p">(</span><span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">coord1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">coord1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">_calEuclideanDist</span><span class="p">(</span><span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">coord1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">coord1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Initialize grid ====================================================-</span>
    <span class="c1"># Evaluate value f(n) = g(n) + h(n)</span>
    <span class="n">gridStatus</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">column</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ro</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="n">ro</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">barriers</span><span class="p">):</span>
                <span class="c1"># Content in the dictionary (g(n), h(n), fromCoord)</span>
                <span class="c1"># At this stage, no need to calculate h(n) </span>
                <span class="n">gridStatus</span><span class="p">[(</span><span class="n">col</span><span class="p">,</span> <span class="n">ro</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gridStatus</span><span class="p">[(</span><span class="n">col</span><span class="p">,</span> <span class="n">ro</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;block&#39;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">distMeasure</span> <span class="o">==</span> <span class="s1">&#39;Manhatten&#39;</span><span class="p">):</span>
        <span class="n">gridStatus</span><span class="p">[</span><span class="n">pt1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_calManhattenDist</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">distMeasure</span> <span class="o">==</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">):</span>
        <span class="n">gridStatus</span><span class="p">[</span><span class="n">pt1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_calEuclideanDist</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">gridStatus</span><span class="p">[</span><span class="n">pt2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Open/close set ======================================================</span>
    <span class="n">openList</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt1</span><span class="p">]</span>
    <span class="n">closeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">barriers</span><span class="p">]</span>

    <span class="c1"># Find smallest Fn ====================================================</span>
    <span class="k">def</span> <span class="nf">_findSmallestFnGrid</span><span class="p">():</span>
        <span class="n">bestFn</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">bestCoord</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">openList</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;block&#39;</span> 
                <span class="ow">and</span> <span class="p">(</span><span class="n">bestFn</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bestFn</span><span class="p">)):</span>
                <span class="n">bestFn</span> <span class="o">=</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">bestCoord</span> <span class="o">=</span> <span class="n">coord</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bestCoord</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">bestCoord</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span>

    <span class="c1"># For each grid in open set, update g(n) ==============================</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">openList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">tmpOpenList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">_findSmallestFnGrid</span><span class="p">()</span>
        <span class="c1"># Up</span>
        <span class="n">upCoord</span> <span class="o">=</span> <span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">row</span> <span class="ow">and</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">upCoord</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">upCoord</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;block&#39;</span> <span class="ow">and</span> <span class="n">upCoord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">closeList</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">gridStatus</span><span class="p">[</span><span class="n">upCoord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">upCoord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">distMeasure</span> <span class="o">==</span> <span class="s1">&#39;Manhatten&#39;</span><span class="p">):</span>
                    <span class="n">gridStatus</span><span class="p">[</span><span class="n">upCoord</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_calManhattenDist</span><span class="p">(</span><span class="n">upCoord</span><span class="p">,</span> <span class="n">pt2</span><span class="p">),</span> <span class="n">coord</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">distMeasure</span> <span class="o">==</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">):</span>
                    <span class="n">gridStatus</span><span class="p">[</span><span class="n">upCoord</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_calEuclideanDist</span><span class="p">(</span><span class="n">upCoord</span><span class="p">,</span> <span class="n">pt2</span><span class="p">),</span> <span class="n">coord</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">upCoord</span> <span class="o">==</span> <span class="n">pt2</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tmpOpenList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">upCoord</span><span class="p">)</span>
        <span class="c1"># Down</span>
        <span class="n">downCoord</span> <span class="o">=</span> <span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">downCoord</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">downCoord</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;block&#39;</span> <span class="ow">and</span> <span class="n">downCoord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">closeList</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">gridStatus</span><span class="p">[</span><span class="n">downCoord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">downCoord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">distMeasure</span> <span class="o">==</span> <span class="s1">&#39;Manhatten&#39;</span><span class="p">):</span>
                    <span class="n">gridStatus</span><span class="p">[</span><span class="n">downCoord</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_calManhattenDist</span><span class="p">(</span><span class="n">downCoord</span><span class="p">,</span> <span class="n">pt2</span><span class="p">),</span> <span class="n">coord</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">distMeasure</span> <span class="o">==</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">):</span>
                    <span class="n">gridStatus</span><span class="p">[</span><span class="n">downCoord</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_calEuclideanDist</span><span class="p">(</span><span class="n">downCoord</span><span class="p">,</span> <span class="n">pt2</span><span class="p">),</span> <span class="n">coord</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">downCoord</span> <span class="o">==</span> <span class="n">pt2</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tmpOpenList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">downCoord</span><span class="p">)</span>
        <span class="c1"># Left</span>
        <span class="n">leftCoord</span> <span class="o">=</span> <span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">leftCoord</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">leftCoord</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;block&#39;</span> <span class="ow">and</span> <span class="n">leftCoord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">closeList</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">gridStatus</span><span class="p">[</span><span class="n">leftCoord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">leftCoord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">distMeasure</span> <span class="o">==</span> <span class="s1">&#39;Manhatten&#39;</span><span class="p">):</span>
                    <span class="n">gridStatus</span><span class="p">[</span><span class="n">leftCoord</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_calManhattenDist</span><span class="p">(</span><span class="n">leftCoord</span><span class="p">,</span> <span class="n">pt2</span><span class="p">),</span> <span class="n">coord</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">distMeasure</span> <span class="o">==</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">):</span>
                    <span class="n">gridStatus</span><span class="p">[</span><span class="n">leftCoord</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_calEuclideanDist</span><span class="p">(</span><span class="n">leftCoord</span><span class="p">,</span> <span class="n">pt2</span><span class="p">),</span> <span class="n">coord</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">leftCoord</span> <span class="o">==</span> <span class="n">pt2</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tmpOpenList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leftCoord</span><span class="p">)</span>
        <span class="c1"># Right</span>
        <span class="n">rightCoord</span> <span class="o">=</span> <span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">column</span> <span class="ow">and</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">rightCoord</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">rightCoord</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;block&#39;</span> <span class="ow">and</span> <span class="n">rightCoord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">closeList</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">gridStatus</span><span class="p">[</span><span class="n">rightCoord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">rightCoord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">distMeasure</span> <span class="o">==</span> <span class="s1">&#39;Manhatten&#39;</span><span class="p">):</span>
                    <span class="n">gridStatus</span><span class="p">[</span><span class="n">rightCoord</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_calManhattenDist</span><span class="p">(</span><span class="n">rightCoord</span><span class="p">,</span> <span class="n">pt2</span><span class="p">),</span> <span class="n">coord</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">distMeasure</span> <span class="o">==</span> <span class="s1">&#39;Euclidean&#39;</span><span class="p">):</span>
                    <span class="n">gridStatus</span><span class="p">[</span><span class="n">rightCoord</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">gridStatus</span><span class="p">[</span><span class="n">coord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_calEuclideanDist</span><span class="p">(</span><span class="n">rightCoord</span><span class="p">,</span> <span class="n">pt2</span><span class="p">),</span> <span class="n">coord</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">rightCoord</span> <span class="o">==</span> <span class="n">pt2</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tmpOpenList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rightCoord</span><span class="p">)</span>
        <span class="n">openList</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="n">openList</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tmpOpenList</span><span class="p">)</span>
        <span class="n">closeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>

    <span class="c1"># Recover path ========================================================</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curCoord</span> <span class="o">=</span> <span class="n">pt2</span>
    <span class="n">finishReconstructFlag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">finishReconstructFlag</span><span class="p">):</span>
        <span class="n">finishReconstructFlag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">curCoord</span><span class="p">)</span>
        <span class="n">curCoord</span> <span class="o">=</span> <span class="n">gridStatus</span><span class="p">[</span><span class="n">curCoord</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">curCoord</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">finishReconstructFlag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="n">path</span>
    <span class="p">}</span>

<span class="c1"># Path touring through polygons ===============================================</span>
<div class="viewcode-block" id="polyPath2Mileage">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.polyPath2Mileage">[docs]</a>
<span class="k">def</span> <span class="nf">polyPath2Mileage</span><span class="p">(</span><span class="n">repSeq</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>

    <span class="c1"># NOTE: 根据p2pPath，得到足够多的子问题信息以生成cut</span>
    <span class="c1"># Step 1: 先把转折点找出来</span>
    <span class="c1"># NOTE: error取值不能太小，因为用的是30边形拟合的圆 + poly2Poly，导致误差其实还蛮大的</span>
    <span class="n">degenPath</span> <span class="o">=</span> <span class="n">locSeqRemoveDegen</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">)</span>

    <span class="c1"># Step 2: 按照转折点，找到路径与每个poly的合法相交部分</span>
    <span class="n">mileage</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lastTurnPt</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">turnPtMileageAcc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">degenPath</span><span class="p">[</span><span class="s1">&#39;removedFlag&#39;</span><span class="p">])):</span>
        <span class="c1"># 接下来分情况讨论：</span>
        <span class="c1"># NOTE: 单独/重合 =&gt; 在该坐标上有一个解还是多个解</span>
        <span class="c1"># NOTE: 转折/穿透 =&gt; path访问该poly的时候是相切还是相交</span>
        <span class="c1"># Case 1: 单独转折点</span>
        <span class="c1"># Case 2: 重合转折点</span>
        <span class="c1"># Case 3: 单独穿透点</span>
        <span class="c1"># Case 4: 重合穿透点</span>
        <span class="n">aggNode</span> <span class="o">=</span> <span class="n">degenPath</span><span class="p">[</span><span class="s1">&#39;aggNodeList&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># 转折点的情形</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">degenPath</span><span class="p">[</span><span class="s1">&#39;removedFlag&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># 先得到当前转折点的坐标</span>
            <span class="n">curLoc</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">distAdd2Acc</span> <span class="o">=</span> <span class="kc">None</span>
            
            <span class="c1"># Case 1: 单独转折点</span>
            <span class="c1"># NOTE: 生成一个Touch的Single点，该点的mileage为lastTurnPt到该点的距离</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aggNode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">turnNode</span> <span class="o">=</span> <span class="n">aggNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">curLoc</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">turnNode</span><span class="p">]</span>
                <span class="n">distAdd2Acc</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">lastTurnPt</span><span class="p">,</span> <span class="n">curLoc</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                <span class="n">mileage</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">repSeq</span><span class="p">[</span><span class="n">turnNode</span><span class="p">],</span>
                    <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Touch&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">curLoc</span><span class="p">,</span>
                    <span class="s1">&#39;mileage&#39;</span><span class="p">:</span> <span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">distAdd2Acc</span>
                <span class="p">})</span>
            
            <span class="c1"># Case 2: 重合转折点</span>
            <span class="c1"># NOTE: 这种情况下，要区分每个重合在此处的转折点与neighborhood是相交还是相切</span>
            <span class="c1"># NOTE: 对于相交的，返回mileage的范围，对于相切的，则视作转折点</span>
            <span class="c1"># NOTE: 注意，至少一个是转折点</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curLoc</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">aggNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">distAdd2Acc</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">lastTurnPt</span><span class="p">,</span> <span class="n">curLoc</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                <span class="c1"># 重合转折点中的相切的点的集合</span>
                <span class="n">tangNodes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">aggNode</span><span class="p">:</span>
                    <span class="c1"># 来判断是相交还是相切</span>
                    <span class="n">inclNode</span> <span class="o">=</span> <span class="n">k</span>
                    <span class="n">neiIntSeg</span> <span class="o">=</span> <span class="n">intSeg2Poly</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">lastTurnPt</span><span class="p">,</span> <span class="n">curLoc</span><span class="p">],</span> 
                        <span class="n">nodes</span><span class="p">[</span><span class="n">repSeq</span><span class="p">[</span><span class="n">inclNode</span><span class="p">]][</span><span class="s1">&#39;neighbor&#39;</span><span class="p">])</span>
                    <span class="c1"># 如果是相交，则处理成穿透点</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">neiIntSeg</span><span class="p">[</span><span class="s1">&#39;intersectType&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Segment&#39;</span><span class="p">):</span>
                        <span class="n">intSeg</span> <span class="o">=</span> <span class="n">neiIntSeg</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">]</span>
                        <span class="n">loc1</span> <span class="o">=</span> <span class="n">intSeg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">loc2</span> <span class="o">=</span> <span class="n">intSeg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">dist1</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">loc1</span><span class="p">,</span> <span class="n">lastTurnPt</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                        <span class="n">dist2</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">loc2</span><span class="p">,</span> <span class="n">lastTurnPt</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                        <span class="c1"># 相交实际上是相切的数值问题</span>
                        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dist1</span> <span class="o">-</span> <span class="n">dist2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">):</span>
                            <span class="n">tangNodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="p">(</span><span class="n">dist1</span> <span class="o">&lt;</span> <span class="n">dist2</span><span class="p">):</span>
                            <span class="n">mileage</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                                <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">repSeq</span><span class="p">[</span><span class="n">inclNode</span><span class="p">],</span>
                                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Intersect&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span><span class="p">],</span>
                                <span class="s1">&#39;mileage&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">dist1</span><span class="p">,</span> <span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">dist2</span><span class="p">]</span>
                            <span class="p">})</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">mileage</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                                <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">repSeq</span><span class="p">[</span><span class="n">inclNode</span><span class="p">],</span>
                                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Intersect&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">loc2</span><span class="p">,</span> <span class="n">loc1</span><span class="p">],</span>
                                <span class="s1">&#39;mileage&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">dist2</span><span class="p">,</span> <span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">dist1</span><span class="p">]</span>
                            <span class="p">})</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tangNodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tangNodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">mileage</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">repSeq</span><span class="p">[</span><span class="n">tangNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Touch&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">curLoc</span><span class="p">,</span>
                        <span class="s1">&#39;mileage&#39;</span><span class="p">:</span> <span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">distAdd2Acc</span>
                    <span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mileage</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">repSeq</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tangNodes</span><span class="p">],</span>
                        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Touch&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">curLoc</span><span class="p">,</span>
                        <span class="s1">&#39;mileage&#39;</span><span class="p">:</span> <span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">distAdd2Acc</span>
                    <span class="p">})</span>

            <span class="c1"># 转折点的话更新一下lastTurnPt，因为现在是最后一个转折点了</span>
            <span class="c1"># NOTE: 不是转折点就不用更新</span>
            <span class="n">lastTurnPt</span> <span class="o">=</span> <span class="n">curLoc</span>
            <span class="n">turnPtMileageAcc</span> <span class="o">+=</span> <span class="n">distAdd2Acc</span>
        
        <span class="c1"># 穿透点的情形</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Case 3: 单独穿透点</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aggNode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># 穿透点所在的线段</span>
                <span class="n">inclNode</span> <span class="o">=</span> <span class="n">aggNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">neiIntSeg</span> <span class="o">=</span> <span class="n">intSeg2Poly</span><span class="p">(</span>
                    <span class="n">degenPath</span><span class="p">[</span><span class="s1">&#39;locatedSeg&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> 
                    <span class="n">nodes</span><span class="p">[</span><span class="n">repSeq</span><span class="p">[</span><span class="n">inclNode</span><span class="p">]][</span><span class="s1">&#39;neighbor&#39;</span><span class="p">])</span>
                
                <span class="c1"># Case 3.1: 最正常的情况，path穿过poly，相交为一个线段</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">neiIntSeg</span><span class="p">[</span><span class="s1">&#39;intersectType&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Segment&#39;</span><span class="p">):</span>
                    <span class="n">intSeg</span> <span class="o">=</span> <span class="n">neiIntSeg</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">]</span>
                    <span class="n">loc1</span> <span class="o">=</span> <span class="n">intSeg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">loc2</span> <span class="o">=</span> <span class="n">intSeg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">dist1</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">loc1</span><span class="p">,</span> <span class="n">lastTurnPt</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                    <span class="n">dist2</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">loc2</span><span class="p">,</span> <span class="n">lastTurnPt</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">dist1</span> <span class="o">&lt;</span> <span class="n">dist2</span><span class="p">):</span>
                        <span class="n">mileage</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                            <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">repSeq</span><span class="p">[</span><span class="n">inclNode</span><span class="p">],</span>
                            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Intersect&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span><span class="p">],</span>
                            <span class="s1">&#39;mileage&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">dist1</span><span class="p">,</span> <span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">dist2</span><span class="p">]</span>
                        <span class="p">})</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">mileage</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                            <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">repSeq</span><span class="p">[</span><span class="n">inclNode</span><span class="p">],</span>
                            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Intersect&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">loc2</span><span class="p">,</span> <span class="n">loc1</span><span class="p">],</span>
                            <span class="s1">&#39;mileage&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">dist2</span><span class="p">,</span> <span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">dist1</span><span class="p">]</span>
                        <span class="p">})</span>

                <span class="c1"># Case 3.2: 特殊情况下，如果穿透点+单独点为neighbor的切点，此时把穿透点处理成转折点</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">neiIntSeg</span><span class="p">[</span><span class="s1">&#39;intersectType&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Point&#39;</span><span class="p">):</span>
                    <span class="n">tangLoc</span> <span class="o">=</span> <span class="n">neiIntSeg</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">]</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">tangLoc</span><span class="p">,</span> <span class="n">lastTurnPt</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                    <span class="n">mileage</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">repSeq</span><span class="p">[</span><span class="n">inclNode</span><span class="p">],</span>
                        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Touch&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">tangLoc</span><span class="p">,</span>
                        <span class="s1">&#39;mileage&#39;</span><span class="p">:</span> <span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">dist</span><span class="p">,</span>
                        <span class="s1">&#39;info&#39;</span><span class="p">:</span> <span class="s1">&#39;Tangent&#39;</span>
                    <span class="p">})</span>
                    <span class="n">lastTurnPt</span> <span class="o">=</span> <span class="n">tangLoc</span>
                    <span class="n">turnPtMileageAcc</span> <span class="o">+=</span> <span class="n">dist</span>
                
                <span class="c1"># Case 3.No: 正常情况下这个分支不应该存在，但是实际上因为精度的问题就是会出现</span>
                <span class="c1"># NOTE: 处理成相切点，相切处为线段上离poly最近点</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tangLoc</span> <span class="o">=</span> <span class="n">nearestPtLine2Poly</span><span class="p">(</span>
                        <span class="n">degenPath</span><span class="p">[</span><span class="s1">&#39;locatedSeg&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> 
                        <span class="n">nodes</span><span class="p">[</span><span class="n">repSeq</span><span class="p">[</span><span class="n">inclNode</span><span class="p">]][</span><span class="s1">&#39;neighbor&#39;</span><span class="p">])[</span><span class="s1">&#39;ptOnLine&#39;</span><span class="p">]</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">tangLoc</span><span class="p">,</span> <span class="n">lastTurnPt</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                    <span class="n">mileage</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">repSeq</span><span class="p">[</span><span class="n">inclNode</span><span class="p">],</span>
                        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Touch&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">tangLoc</span><span class="p">,</span>
                        <span class="s1">&#39;mileage&#39;</span><span class="p">:</span> <span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">dist</span><span class="p">,</span>
                        <span class="s1">&#39;info&#39;</span><span class="p">:</span> <span class="s1">&#39;TangentError&#39;</span>
                    <span class="p">})</span>
                    <span class="n">lastTurnPt</span> <span class="o">=</span> <span class="n">tangLoc</span>
                    <span class="n">turnPtMileageAcc</span> <span class="o">+=</span> <span class="n">dist</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;WARNING: Numerical issue when calculating mileage.&quot;</span><span class="p">)</span>
            
            <span class="c1"># Case 4: 重合穿透点</span>
            <span class="c1"># FIXME: 这部分代码要好好走查一下</span>
            <span class="c1"># NOTE: 这个情况很复杂，如果存在至少一个相切的情况，那么该点实际上是转折点，且是多重转折点</span>
            <span class="c1"># NOTE: 需要挨个确认是否是相切点，如果是相切点，按相切点处理（聚合在一起），如果不是相切点，依次计算mileage</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tangFlag</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">tangLoc</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">neiIntSet</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">degenPath</span><span class="p">[</span><span class="s1">&#39;aggNodeList&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
                    <span class="c1"># 穿透点所在的线段</span>
                    <span class="n">neiInt</span> <span class="o">=</span> <span class="n">intSeg2Poly</span><span class="p">(</span>
                        <span class="n">degenPath</span><span class="p">[</span><span class="s1">&#39;locatedSeg&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> 
                        <span class="n">nodes</span><span class="p">[</span><span class="n">repSeq</span><span class="p">[</span><span class="n">k</span><span class="p">]][</span><span class="s1">&#39;neighbor&#39;</span><span class="p">])</span>
                    <span class="n">neiIntSet</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">repSeq</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">neiInt</span><span class="p">))</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">neiInt</span><span class="p">[</span><span class="s1">&#39;intersectType&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Point&#39;</span><span class="p">):</span>
                        <span class="n">tangFlag</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="c1"># 虽然一直在更新，但是理论上应该是同一个点</span>
                        <span class="n">tangLoc</span> <span class="o">=</span> <span class="n">neiInt</span><span class="p">[</span><span class="s1">&#39;intersect&#39;</span><span class="p">]</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">tangFlag</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">intSeg</span> <span class="ow">in</span> <span class="n">neiIntSet</span><span class="p">:</span>
                        <span class="n">loc1</span> <span class="o">=</span> <span class="n">intSeg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;intersect&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">loc2</span> <span class="o">=</span> <span class="n">intSeg</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;intersect&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">dist1</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">loc1</span><span class="p">,</span> <span class="n">lastTurnPt</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                        <span class="n">dist2</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">loc2</span><span class="p">,</span> <span class="n">lastTurnPt</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">dist1</span> <span class="o">&lt;</span> <span class="n">dist2</span><span class="p">):</span>
                            <span class="n">mileage</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                                <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">intSeg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Intersect&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span><span class="p">],</span>
                                <span class="s1">&#39;mileage&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">dist1</span><span class="p">,</span> <span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">dist2</span><span class="p">]</span>
                            <span class="p">})</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">mileage</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                                <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="n">intSeg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Intersect&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">loc2</span><span class="p">,</span> <span class="n">loc1</span><span class="p">],</span>
                                <span class="s1">&#39;mileage&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">dist2</span><span class="p">,</span> <span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">dist1</span><span class="p">]</span>
                            <span class="p">})</span>

                <span class="c1"># Case 4.1: 特殊情况下，如果穿透点+重合点为neighbor的切点，此时把穿透点处理成转折点</span>
                <span class="c1"># NOTE: 这个目前很罕见，但是应该也可以生成对应的算例</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">tangLoc</span><span class="p">,</span> <span class="n">lastTurnPt</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                    <span class="n">mileage</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;polyID&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">repSeq</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">degenPath</span><span class="p">[</span><span class="s1">&#39;aggNodeList&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]],</span>
                        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Touch&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;intersect&#39;</span><span class="p">:</span> <span class="n">tangLoc</span><span class="p">,</span>
                        <span class="s1">&#39;mileage&#39;</span><span class="p">:</span> <span class="n">turnPtMileageAcc</span> <span class="o">+</span> <span class="n">dist</span><span class="p">,</span>
                        <span class="s1">&#39;info&#39;</span><span class="p">:</span> <span class="s1">&#39;Tangent&#39;</span>
                    <span class="p">})</span>
                    <span class="n">lastTurnPt</span> <span class="o">=</span> <span class="n">tangLoc</span>
                    <span class="n">turnPtMileageAcc</span> <span class="o">+=</span> <span class="n">dist</span>
    
    <span class="k">return</span> <span class="n">mileage</span></div>


<div class="viewcode-block" id="locSeqRemoveDegen">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.locSeqRemoveDegen">[docs]</a>
<span class="k">def</span> <span class="nf">locSeqRemoveDegen</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span> <span class="n">error</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="n">CONST_EPSILON</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a sequence of points, returns a subset of points that only includes turning points of the sequence. If there are multiple points overlapped at the same location, keeps one of those points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seq: list[pt], required</span>
<span class="sd">        The coordinates of a sequence of points.</span>
<span class="sd">    error: float, optional, default as CONST_EPSILON</span>
<span class="sd">        Error tolerance.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A new dictionary, in the format of </span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; {</span>
<span class="sd">        ...     &#39;newSeq&#39;: newSeq, </span>
<span class="sd">        ...     &#39;aggNodeList&#39;: aggNodeList, </span>
<span class="sd">        ...     &#39;removedFlag&#39;: removedFlag, </span>
<span class="sd">        ...     &#39;locatedSeg&#39;: locatedSeg</span>
<span class="sd">        ... }</span>

<span class="sd">        - The &#39;newSeq&#39; returns a new sequence which only has turn points of the origin sequence</span>
<span class="sd">        - The &#39;aggNodeList&#39; is a list of lists, if a point overlaps with its previous/next point, the index of both points will be aggregated into the same list.</span>
<span class="sd">        - The &#39;removedFlag&#39; indicates whether a point is removed as a non-turning point, true if the point is not included in the &#39;newSeq&#39;</span>
<span class="sd">        - The &#39;locatedSeq&#39; returns a list of line segments, for each point removed, it returns the line segment it belongs to </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For the following inputs</span>
<span class="sd">        &gt;&gt;&gt; seq = [[-1, 0], [0, 0], [0, 0], [1, 0], [2, 0], [2, 1], [1, 1], [1, 0], [1, -1]]</span>
<span class="sd">        &gt;&gt;&gt; res = locSeqRemoveDegen(seq)</span>
<span class="sd">    The result is as follows</span>
<span class="sd">        &gt;&gt;&gt; res = {&#39;newSeq&#39;: [[-1, 0], [2, 0], [2, 1], [1, 1], [1, -1]],</span>
<span class="sd">        ...     &#39;aggNodeList&#39;: [[0], [1, 2], [3], [4], [5], [6], [7], [8]],</span>
<span class="sd">        ...     &#39;removedFlag&#39;: [False, True, True, False, False, False, True, False],</span>
<span class="sd">        ...     &#39;locatedSeg&#39;: [None,</span>
<span class="sd">        ...      [[-1, 0], [2, 0]],</span>
<span class="sd">        ...      [[-1, 0], [2, 0]],</span>
<span class="sd">        ...      None,</span>
<span class="sd">        ...      None,</span>
<span class="sd">        ...      None,</span>
<span class="sd">        ...      [[1, 1], [1, -1]],</span>
<span class="sd">        ...      None]</span>
<span class="sd">        ... }</span>
<span class="sd">    The result shows that, the new sequence is [[-1, 0], [2, 0], [2, 1], [1, 1], [1, -1]], in the new sequence, seq[1], seq[2], seq[6] are not included since they are not turn points.</span>
<span class="sd">    seq[1] and seq[2] are aggregated due to overlaps. Although seq[3] and seq[6] are overlapped, they are not aggregated because they are not neighboring. </span>
<span class="sd">    For the removed points, &#39;locatedSeq&#39; finds the segment they located.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Step 1: 先按是否重合对点进行聚合  </span>
    <span class="n">curLoc</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">curAgg</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">aggNodeList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># 挤香肠算法</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>
        <span class="c1"># 如果当前点重复，则计入</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is2PtsSame</span><span class="p">(</span><span class="n">curLoc</span><span class="p">,</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">error</span><span class="p">)):</span>
            <span class="n">curAgg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="c1"># 若不重复，了结</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aggNodeList</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curAgg</span><span class="p">])</span>
            <span class="n">curAgg</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">curLoc</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">aggNodeList</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curAgg</span><span class="p">])</span>

    <span class="c1"># Step 2: 对聚合后的点，判断是否为转折点</span>
    <span class="c1"># NOTE: removeFlag的长度和aggNodeList一致</span>
    <span class="n">removedFlag</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggNodeList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">preLoc</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">aggNodeList</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">aggNodeList</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span> <span class="k">else</span> <span class="n">aggNodeList</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">curLoc</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">aggNodeList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">aggNodeList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span> <span class="k">else</span> <span class="n">aggNodeList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">sucLoc</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">aggNodeList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">aggNodeList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span> <span class="k">else</span> <span class="n">aggNodeList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>

        <span class="n">dev</span> <span class="o">=</span> <span class="n">distPt2Seg</span><span class="p">(</span><span class="n">curLoc</span><span class="p">,</span> <span class="p">[</span><span class="n">preLoc</span><span class="p">,</span> <span class="n">sucLoc</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">&lt;=</span> <span class="n">error</span><span class="p">):</span>
            <span class="n">removedFlag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">removedFlag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">removedFlag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># 得到去掉共线和重合点后的折线</span>
    <span class="n">newSeq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aggNodeList</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">removedFlag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">aggNodeList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">newSeq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">aggNodeList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newSeq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">aggNodeList</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

    <span class="c1"># 对于被移除的共线点，找到其所在的线段</span>
    <span class="n">locatedSeg</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># 把没有移除的点的序号记一下</span>
    <span class="n">seqPre</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">seqSuc</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># 查找移除点之前和之后一个removeFlag为False的对应aggNode，得到对应线段</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">removedFlag</span><span class="p">)):</span>
        <span class="c1"># Log the prev unremoved</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">removedFlag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">seqPre</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seqPre</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seqPre</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Log the next unremoved</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">removedFlag</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">removedFlag</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">seqSuc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">removedFlag</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seqSuc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">seqSuc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">removedFlag</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">removedFlag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">locatedSeg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">para</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">startLoc</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">aggNodeList</span><span class="p">[</span><span class="n">seqPre</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">startLoc</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">aggNodeList</span><span class="p">[</span><span class="n">seqPre</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">startLoc</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">aggNodeList</span><span class="p">[</span><span class="n">seqPre</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
            <span class="n">endLoc</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">aggNodeList</span><span class="p">[</span><span class="n">seqSuc</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">endLoc</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">aggNodeList</span><span class="p">[</span><span class="n">seqSuc</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">endLoc</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">aggNodeList</span><span class="p">[</span><span class="n">seqSuc</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
            <span class="n">locatedSeg</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">startLoc</span><span class="p">,</span> <span class="n">endLoc</span><span class="p">])</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;newSeq&#39;</span><span class="p">:</span> <span class="n">newSeq</span><span class="p">,</span>
        <span class="s1">&#39;aggNodeList&#39;</span><span class="p">:</span> <span class="n">aggNodeList</span><span class="p">,</span>
        <span class="s1">&#39;removedFlag&#39;</span><span class="p">:</span> <span class="n">removedFlag</span><span class="p">,</span>
        <span class="s1">&#39;locatedSeg&#39;</span><span class="p">:</span> <span class="n">locatedSeg</span>
    <span class="p">}</span></div>


<span class="c1"># obj2ObjPath =================================================================</span>
<div class="viewcode-block" id="poly2PolyPath">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.poly2PolyPath">[docs]</a>
<span class="k">def</span> <span class="nf">poly2PolyPath</span><span class="p">(</span><span class="n">startPt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">endPt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">polys</span><span class="p">:</span> <span class="n">polys</span><span class="p">,</span> <span class="n">algo</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;SOCP&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a starting point, a list of polys, and an ending point, returns a shortest route that starts from startPt, visits every polys in given order, and returns to the ending point.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    startPt: pt, required, default None</span>
<span class="sd">        The coordinate which starts the path.</span>
<span class="sd">    endPt: pt, required, default None</span>
<span class="sd">        The coordinate which ends the path.</span>
<span class="sd">    polys: polys, required</span>
<span class="sd">        A list of polys to be visited in given sequence</span>
<span class="sd">    algo: str, optional, default as &#39;SOCP&#39;</span>
<span class="sd">        Select the algorithm for calculating the shortest path. Options and required additional inputs are as follows:</span>
<span class="sd">            </span>
<span class="sd">        1) (default) &#39;SOCP&#39;, use Second-order Cone Programing method.</span>
<span class="sd">            - solver: str, optional, now only supports &#39;Gurobi&#39;</span>
<span class="sd">            - timeLimit: int|float, additional stopping criteria</span>
<span class="sd">            - gapTolerance: int|float, additional stopping criteria</span>
<span class="sd">            - outputFlag: bool, True if turn on the log output from solver. Default to be False</span>
<span class="sd">        2) &#39;AdaptIter&#39;, use adapt iteration algorithm</span>
<span class="sd">            - errorTol: float, optional, error tolerance</span>
<span class="sd">    **kwargs: optional</span>
<span class="sd">        Provide additional inputs for different `edges` options and `algo` options</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Two fields in the dictionary, &#39;dist&#39; indicates the distance of the path, &#39;path&#39; indicates the travel path.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sanity check ============================================================</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: Missing required field `method`.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">algo</span> <span class="o">==</span> <span class="s1">&#39;AdaptIter&#39;</span><span class="p">):</span>
        <span class="n">errTol</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;errTol&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="n">errTol</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;errTol&#39;</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_poly2PolyPathAdaptIter</span><span class="p">(</span><span class="n">startPt</span><span class="p">,</span> <span class="n">endPt</span><span class="p">,</span> <span class="n">polys</span><span class="p">,</span> <span class="n">errTol</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">algo</span> <span class="o">==</span> <span class="s1">&#39;SOCP&#39;</span><span class="p">):</span>
        <span class="n">outputFlag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;outputFlag&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="n">outputFlag</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;outputFlag&#39;</span><span class="p">]</span>
        <span class="n">gapTol</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;gapTol&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="n">gapTol</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;gapTol&#39;</span><span class="p">]</span>
        <span class="n">timeLimit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;timeLimit&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="n">timeLimit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;timeLimit&#39;</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_poly2PolyPathGurobi</span><span class="p">(</span><span class="n">startPt</span><span class="p">,</span> <span class="n">endPt</span><span class="p">,</span> <span class="n">polys</span><span class="p">,</span> <span class="n">outputFlag</span><span class="p">,</span> <span class="n">gapTol</span><span class="p">,</span> <span class="n">timeLimit</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnsupportedInputError</span><span class="p">(</span><span class="s2">&quot;ERROR: Not support by vrpSolver for now.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">],</span>
        <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
    <span class="p">}</span></div>


<span class="k">def</span> <span class="nf">_poly2PolyPathAdaptIter</span><span class="p">(</span><span class="n">startPt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">endPt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">polys</span><span class="p">:</span> <span class="n">polys</span><span class="p">,</span> <span class="n">errTol</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a list of points, each belongs to a neighborhood of a node, find the shortest path between each steps</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    polys: list of polygons, required</span>
<span class="sd">        A list of polygons to be visited</span>
<span class="sd">    solver: string, optional, default AVAIL_SOLVER</span>
<span class="sd">        The commercial solver used to solve the minimum cost flow problem</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># First, create a ring, to help keying each extreme points of polygons</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Initialize</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">polyRings</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
        <span class="n">polyRing</span> <span class="o">=</span> <span class="n">Ring</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)):</span>
            <span class="n">polyRing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">RingNode</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">poly</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">polyRings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polyRing</span><span class="p">)</span>

    <span class="c1"># startPt to the first polygon</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">polyRings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">head</span>
    <span class="k">while</span> <span class="p">(</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">startPt</span><span class="p">,</span> <span class="n">cur</span><span class="o">.</span><span class="n">value</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
        <span class="n">tau</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cur</span><span class="o">.</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">d</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cur</span><span class="o">.</span><span class="n">key</span><span class="p">),</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">next</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">polyRings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">key</span><span class="p">):</span>
            <span class="k">break</span>

    <span class="c1"># If more than one polygon btw startPt and endPt</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">curI</span> <span class="o">=</span> <span class="n">polyRings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="p">(</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">curJ</span> <span class="o">=</span> <span class="n">polyRings</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">head</span>
            <span class="k">while</span> <span class="p">(</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">curI</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">curJ</span><span class="o">.</span><span class="n">value</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                <span class="n">tau</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">curI</span><span class="o">.</span><span class="n">key</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">curJ</span><span class="o">.</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">d</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">curI</span><span class="o">.</span><span class="n">key</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">curJ</span><span class="o">.</span><span class="n">key</span><span class="p">),</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">d</span><span class="p">)</span>
                <span class="n">curJ</span> <span class="o">=</span> <span class="n">curJ</span><span class="o">.</span><span class="n">next</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">curJ</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">polyRings</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">key</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="n">curI</span> <span class="o">=</span> <span class="n">curI</span><span class="o">.</span><span class="n">next</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">curI</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">polyRings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">key</span><span class="p">):</span>
                <span class="k">break</span>

    <span class="c1"># last polygon to endPt</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">polyRings</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">head</span>
    <span class="k">while</span> <span class="p">(</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">endPt</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
        <span class="n">tau</span><span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur</span><span class="o">.</span><span class="n">key</span><span class="p">),</span> <span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur</span><span class="o">.</span><span class="n">key</span><span class="p">),</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">next</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">polyRings</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">key</span><span class="p">):</span>
            <span class="k">break</span>

    <span class="n">sp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">)</span>

    <span class="n">dist</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">startPt</span><span class="p">,</span> <span class="n">polyRings</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">value</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">+=</span> <span class="n">tau</span><span class="p">[(</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])]</span>
    <span class="n">dist</span> <span class="o">+=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">polyRings</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">endPt</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
    
    <span class="c1"># Find detailed location</span>
    <span class="n">refineFlag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">iterNum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">refineFlag</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Find current shortest intersecting point</span>
            <span class="n">polyIdx</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">exPtIdx</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Insert two new points before and after this point</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">polyRings</span><span class="p">[</span><span class="n">polyIdx</span><span class="p">]</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">exPtIdx</span><span class="p">)</span>
            <span class="n">pPrev</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">prev</span>
            <span class="n">pNext</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span>

            <span class="n">pPrevMidLoc</span> <span class="o">=</span> <span class="p">[(</span><span class="n">pPrev</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pPrev</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">pPrev</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pPrev</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>
            <span class="n">pPrevMid</span> <span class="o">=</span> <span class="n">RingNode</span><span class="p">(</span><span class="n">polyRings</span><span class="p">[</span><span class="n">polyIdx</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">pPrevMidLoc</span><span class="p">)</span>
            <span class="n">pNextMidLoc</span> <span class="o">=</span> <span class="p">[(</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pNext</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pNext</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>
            <span class="n">pNextMid</span> <span class="o">=</span> <span class="n">RingNode</span><span class="p">(</span><span class="n">polyRings</span><span class="p">[</span><span class="n">polyIdx</span><span class="p">]</span><span class="o">.</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pNextMidLoc</span><span class="p">)</span>

            <span class="n">polyRings</span><span class="p">[</span><span class="n">polyIdx</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pNextMid</span><span class="p">)</span>
            <span class="n">polyRings</span><span class="p">[</span><span class="n">polyIdx</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pPrev</span><span class="p">,</span> <span class="n">pPrevMid</span><span class="p">)</span>

        <span class="c1"># Simplify the graph</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

        <span class="c1"># New start</span>
        <span class="n">startPolyPt</span> <span class="o">=</span> <span class="n">polyRings</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">startNearPt</span> <span class="o">=</span> <span class="p">[</span><span class="n">startPolyPt</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">startPolyPt</span><span class="o">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">startPolyPt</span><span class="p">,</span> <span class="n">startPolyPt</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">startPolyPt</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">startNearPt</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">startPt</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">key</span><span class="p">),</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">d</span><span class="p">)</span>

        <span class="c1"># In between</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">polyIdx</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">polyNextIdx</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">exPtIdx</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">exPtNextIdx</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">ptI</span> <span class="o">=</span> <span class="n">polyRings</span><span class="p">[</span><span class="n">polyIdx</span><span class="p">]</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">exPtIdx</span><span class="p">)</span>
            <span class="n">ptNearI</span> <span class="o">=</span> <span class="p">[</span><span class="n">ptI</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">ptI</span><span class="o">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">ptI</span><span class="p">,</span> <span class="n">ptI</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">ptI</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span><span class="p">]</span>
            <span class="n">ptJ</span> <span class="o">=</span> <span class="n">polyRings</span><span class="p">[</span><span class="n">polyNextIdx</span><span class="p">]</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">exPtNextIdx</span><span class="p">)</span>
            <span class="n">ptNearJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">ptJ</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">ptJ</span><span class="o">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">ptJ</span><span class="p">,</span> <span class="n">ptJ</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">ptJ</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">kI</span> <span class="ow">in</span> <span class="n">ptNearI</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">kJ</span> <span class="ow">in</span> <span class="n">ptNearJ</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="p">(((</span><span class="n">polyIdx</span><span class="p">,</span> <span class="n">kI</span><span class="o">.</span><span class="n">key</span><span class="p">),</span> <span class="p">(</span><span class="n">polyNextIdx</span><span class="p">,</span> <span class="n">kJ</span><span class="o">.</span><span class="n">key</span><span class="p">))</span> <span class="ow">in</span> <span class="n">tau</span><span class="p">):</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">tau</span><span class="p">[((</span><span class="n">polyIdx</span><span class="p">,</span> <span class="n">kI</span><span class="o">.</span><span class="n">key</span><span class="p">),</span> <span class="p">(</span><span class="n">polyNextIdx</span><span class="p">,</span> <span class="n">kJ</span><span class="o">.</span><span class="n">key</span><span class="p">))]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">kI</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">kJ</span><span class="o">.</span><span class="n">value</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
                        <span class="n">tau</span><span class="p">[((</span><span class="n">polyIdx</span><span class="p">,</span> <span class="n">kI</span><span class="o">.</span><span class="n">key</span><span class="p">),</span> <span class="p">(</span><span class="n">polyNextIdx</span><span class="p">,</span> <span class="n">kJ</span><span class="o">.</span><span class="n">key</span><span class="p">))]</span> <span class="o">=</span> <span class="n">d</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="n">polyIdx</span><span class="p">,</span> <span class="n">kI</span><span class="o">.</span><span class="n">key</span><span class="p">),</span> <span class="p">(</span><span class="n">polyNextIdx</span><span class="p">,</span> <span class="n">kJ</span><span class="o">.</span><span class="n">key</span><span class="p">),</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">d</span><span class="p">)</span>

        <span class="c1"># New end</span>
        <span class="n">endPolyPt</span> <span class="o">=</span> <span class="n">polyRings</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">endNearPt</span> <span class="o">=</span> <span class="p">[</span><span class="n">endPolyPt</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">endPolyPt</span><span class="o">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">endPolyPt</span><span class="p">,</span> <span class="n">endPolyPt</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">endPolyPt</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">endNearPt</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">endPt</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">key</span><span class="p">),</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">d</span><span class="p">)</span>

        <span class="n">sp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">)</span>

        <span class="n">newDist</span> <span class="o">=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">startPt</span><span class="p">,</span> <span class="n">polyRings</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">value</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">newDist</span> <span class="o">+=</span> <span class="n">tau</span><span class="p">[(</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">newDist</span> <span class="o">+=</span> <span class="n">distEuclideanXY</span><span class="p">(</span><span class="n">polyRings</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">endPt</span><span class="p">)[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">newDist</span> <span class="o">-</span> <span class="n">dist</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">errTol</span><span class="p">):</span>
            <span class="n">refineFlag</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">newDist</span>

    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">startPt</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="s1">&#39;s&#39;</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">!=</span> <span class="s1">&#39;e&#39;</span><span class="p">):</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polyRings</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endPt</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="n">path</span><span class="p">,</span>
        <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="n">dist</span>
    <span class="p">}</span>

<span class="k">def</span> <span class="nf">_poly2PolyPathGurobi</span><span class="p">(</span><span class="n">startPt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">endPt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">polys</span><span class="p">:</span> <span class="n">polys</span><span class="p">,</span>  <span class="n">outputFlag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">gapTol</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">timeLimit</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_seg2SegPathGurobi</span><span class="p">(</span>
        <span class="n">startPt</span> <span class="o">=</span> <span class="n">startPt</span><span class="p">,</span> 
        <span class="n">endPt</span> <span class="o">=</span> <span class="n">endPt</span><span class="p">,</span> 
        <span class="n">segs</span> <span class="o">=</span> <span class="n">polys</span><span class="p">,</span> 
        <span class="n">closedFlag</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
        <span class="n">outputFlag</span> <span class="o">=</span> <span class="n">outputFlag</span><span class="p">,</span> 
        <span class="n">gapTol</span> <span class="o">=</span> <span class="n">gapTol</span><span class="p">,</span> 
        <span class="n">timeLimit</span> <span class="o">=</span> <span class="n">timeLimit</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_seg2SegPathGurobi</span><span class="p">(</span><span class="n">startPt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">endPt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">segs</span><span class="p">,</span> <span class="n">closedFlag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">outputFlag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">gapTol</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">timeLimit</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">gurobipy</span> <span class="k">as</span> <span class="nn">grb</span>
    <span class="k">except</span><span class="p">(</span><span class="ne">ImportError</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;ERROR: Cannot find Gurobi&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">grb</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="s2">&quot;SOCP&quot;</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s1">&#39;OutputFlag&#39;</span><span class="p">,</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">outputFlag</span> <span class="o">==</span> <span class="kc">False</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">gapTol</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s1">&#39;MIPGap&#39;</span><span class="p">,</span> <span class="n">gapTol</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">timeLimit</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">Param</span><span class="o">.</span><span class="n">TimeLimit</span><span class="p">,</span> <span class="n">timeLimit</span><span class="p">)</span>

    <span class="c1"># Parameters ==============================================================</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lbX</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">lbY</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ubX</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ubY</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">allX</span> <span class="o">=</span> <span class="p">[</span><span class="n">startPt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">endPt</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">allY</span> <span class="o">=</span> <span class="p">[</span><span class="n">startPt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">endPt</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="n">allX</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">allY</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lbX</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">allX</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">lbY</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">allY</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">ubX</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">allX</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ubY</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">allY</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># close seg flag ==========================================================</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">closedFlag</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segs</span><span class="p">:</span>
            <span class="n">seg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Decision variables ======================================================</span>
    <span class="c1"># (xi, yi) 为第i个seg上的坐标</span>
    <span class="c1"># index = 1, 2, ..., len(segs)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span><span class="o">=</span><span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;x_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">lb</span><span class="o">=</span><span class="n">lbX</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="n">ubX</span><span class="p">)</span>
        <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span><span class="o">=</span><span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;y_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">lb</span><span class="o">=</span><span class="n">lbY</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="n">ubY</span><span class="p">)</span>

    <span class="c1"># e[i, j] 为binary，表示(xi, yi)处于第i个seg上的第j段</span>
    <span class="c1"># index i = 1, 2, ..., len(segs)</span>
    <span class="c1"># index j = 1, ..., len(segs[i]) - 1</span>
    <span class="c1"># lam[i, j] 为[0, 1]之间的值，表示第i段是处于对应e[i, j]上的位置，若e[i, j] = 0，则lam[i, j] = 0</span>
    <span class="n">e</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">lam</span> <span class="o">=</span> <span class="p">{}</span>    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])):</span>
            <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span><span class="o">=</span><span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">BINARY</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;e_</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
            <span class="n">lam</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span><span class="o">=</span><span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;lam_</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

    <span class="c1"># d[i] 为第i个到第i+1个坐标的距离, dx[i], dy[i] 为对应辅助变量</span>
    <span class="c1"># Distance from ((xi, yi)) to (x[i + 1], y[i + 1]), </span>
    <span class="c1"># where startPt = (x[0], y[0]) and endPt = (x[len(circles) + 1], y[len(circles) + 1])</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;d_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">setObjective</span><span class="p">(</span><span class="n">grb</span><span class="o">.</span><span class="n">quicksum</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">MINIMIZE</span><span class="p">)</span>

    <span class="c1"># Aux vars - distance between (x, y)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;dx_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="n">ub</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
        <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;dy_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="n">ub</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>

    <span class="c1"># Constraints =============================================================</span>
    <span class="c1"># (xi, yi)必须在其中一段上</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">grb</span><span class="o">.</span><span class="n">quicksum</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># 具体(xi, yi)的位置，lam[i, j]在e[i, j] = 0的段上不激活</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">grb</span><span class="o">.</span><span class="n">quicksum</span><span class="p">(</span>
            <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">segs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">lam</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">segs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">segs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))))</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">grb</span><span class="o">.</span><span class="n">quicksum</span><span class="p">(</span>
            <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">segs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lam</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">segs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">segs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])):</span>
            <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">lam</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

    <span class="c1"># Aux constr - dx dy</span>
    <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">startPt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">startPt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)]</span> <span class="o">==</span> <span class="n">endPt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)])</span>
    <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dy</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)]</span> <span class="o">==</span> <span class="n">endPt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)])</span>

    <span class="c1"># Distance btw visits</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addQConstr</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># model.write(&quot;SOCP.lp&quot;)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>

    <span class="c1"># close seg flag ==========================================================</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">closedFlag</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segs</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">seg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Post-processing =========================================================</span>
    <span class="n">ofv</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">startPt</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">OPTIMAL</span><span class="p">):</span>
        <span class="n">solType</span> <span class="o">=</span> <span class="s1">&#39;IP_Optimal&#39;</span>
        <span class="n">ofv</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">getObjective</span><span class="p">()</span><span class="o">.</span><span class="n">getValue</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
        <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endPt</span><span class="p">)</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="n">ofv</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">ofv</span>
        <span class="n">runtime</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">Runtime</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">TIME_LIMIT</span><span class="p">):</span>
        <span class="n">solType</span> <span class="o">=</span> <span class="s1">&#39;IP_TimeLimit&#39;</span>
        <span class="n">ofv</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">ObjVal</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
        <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endPt</span><span class="p">)</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">MIPGap</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">ObjBoundC</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">ObjVal</span>
        <span class="n">runtime</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">Runtime</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="n">path</span><span class="p">,</span>
        <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="n">ofv</span><span class="p">,</span>
        <span class="s1">&#39;runtime&#39;</span><span class="p">:</span> <span class="n">runtime</span>
    <span class="p">}</span>

<div class="viewcode-block" id="circle2CirclePath">
<a class="viewcode-back" href="../../vrpSolver.geometry.html#vrpSolver.geometry.circle2CirclePath">[docs]</a>
<span class="k">def</span> <span class="nf">circle2CirclePath</span><span class="p">(</span><span class="n">startPt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">endPt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">circles</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">],</span> <span class="n">algo</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;SOCP&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a starting point, a list of circles, and an ending point, returns a shortest route that starts from startPt, visits every polys in given order, and returns to the ending point.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    startPt: pt, required, default None</span>
<span class="sd">        The coordinate which starts the path.</span>
<span class="sd">    endPt: pt, required, default None</span>
<span class="sd">        The coordinate which ends the path.</span>
<span class="sd">    circles: dict, required</span>
<span class="sd">        A list of circles modeled by dictionaries to be visited in given sequence. Each circle is dictionary with two fields: &#39;radius&#39; and &#39;center&#39;.</span>
<span class="sd">    algo: str, optional, default as &#39;SOCP&#39;</span>
<span class="sd">        Select the algorithm for calculating the shortest path. Options and required additional inputs are as follows:</span>
<span class="sd">            </span>
<span class="sd">        1) (default) &#39;SOCP&#39;, use Second-order Cone Programing method.</span>
<span class="sd">            - solver: str, optional, now supports &#39;Gurobi&#39; and &#39;COPT&#39;</span>
<span class="sd">            - timeLimit: int|float, additional stopping criteria</span>
<span class="sd">            - gapTolerance: int|float, additional stopping criteria</span>
<span class="sd">            - outputFlag: bool, True if turn on the log output from solver. Default to be False</span>
<span class="sd">    **kwargs: optional</span>
<span class="sd">        Provide additional inputs for different `edges` options and `algo` options</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Two fields in the dictionary, &#39;dist&#39; indicates the distance of the path, &#39;path&#39; indicates the travel path.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sanity check ============================================================</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MissingParameterError</span><span class="p">(</span><span class="s2">&quot;ERROR: Missing required field `method`.&quot;</span><span class="p">)</span>

    <span class="n">errTol</span> <span class="o">=</span> <span class="n">CONST_EPSILON</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;errTol&#39;</span> <span class="ow">in</span> <span class="n">method</span><span class="p">):</span>
        <span class="n">errTol</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="s1">&#39;errTol&#39;</span><span class="p">]</span>


    <span class="k">if</span> <span class="p">(</span><span class="n">algo</span> <span class="o">==</span> <span class="s1">&#39;SOCP&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;solver&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;solver&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Gurobi&#39;</span><span class="p">):</span>
            <span class="n">outputFlag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;outputFlag&#39;</span> <span class="ow">in</span> <span class="n">method</span><span class="p">):</span>
                <span class="n">outputFlag</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="s1">&#39;outputFlag&#39;</span><span class="p">]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">_circle2CirclePathGurobi</span><span class="p">(</span><span class="n">startPt</span><span class="p">,</span> <span class="n">endPt</span><span class="p">,</span> <span class="n">circles</span><span class="p">,</span> <span class="n">outputFlag</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;solver&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;COPT&#39;</span><span class="p">):</span>
            <span class="n">outputFlag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;outputFlag&#39;</span> <span class="ow">in</span> <span class="n">method</span><span class="p">):</span>
                <span class="n">outputFlag</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="s1">&#39;outputFlag&#39;</span><span class="p">]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">_circle2CirclePathCOPT</span><span class="p">(</span><span class="n">startPt</span><span class="p">,</span> <span class="n">endPt</span><span class="p">,</span> <span class="n">circles</span><span class="p">,</span> <span class="n">outputFlag</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnsupportedInputError</span><span class="p">(</span><span class="s2">&quot;ERROR: Not support by vrpSolver for now.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">],</span>
        <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>
    <span class="p">}</span></div>


<span class="k">def</span> <span class="nf">_circle2CirclePathGurobi</span><span class="p">(</span><span class="n">startPt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">endPt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">circles</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">],</span> <span class="n">outputFlag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">gurobipy</span> <span class="k">as</span> <span class="nn">grb</span>
    <span class="k">except</span><span class="p">(</span><span class="ne">ImportError</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ERROR: Cannot find Gurobi&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">grb</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="s2">&quot;SOCP&quot;</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s1">&#39;OutputFlag&#39;</span><span class="p">,</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">outputFlag</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Parameters ==============================================================</span>
    <span class="c1"># anchor starts from startPt, in between are a list of circles, ends with endPt</span>
    <span class="n">anchor</span> <span class="o">=</span> <span class="p">[</span><span class="n">startPt</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)):</span>
        <span class="n">anchor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">])</span>
    <span class="n">anchor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endPt</span><span class="p">)</span>

    <span class="n">allX</span> <span class="o">=</span> <span class="p">[</span><span class="n">startPt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">endPt</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">allY</span> <span class="o">=</span> <span class="p">[</span><span class="n">startPt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">endPt</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)):</span>
        <span class="n">allX</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;radius&#39;</span><span class="p">])</span>
        <span class="n">allX</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;radius&#39;</span><span class="p">])</span>
        <span class="n">allY</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;radius&#39;</span><span class="p">])</span>
        <span class="n">allY</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;radius&#39;</span><span class="p">])</span>
    <span class="n">lbX</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">allX</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">lbY</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">allY</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">ubX</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">allX</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">ubY</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">allY</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Decision variables ======================================================</span>
    <span class="c1"># NOTE: x, y index starts by 1</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;x_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="n">lbX</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">ubX</span><span class="p">)</span>
        <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;y_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="n">lbY</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">ubY</span><span class="p">)</span>
    <span class="c1"># Distance from ((xi, yi)) to (x[i + 1], y[i + 1]), </span>
    <span class="c1"># where startPt = (x[0], y[0]) and endPt = (x[len(circles) + 1], y[len(circles) + 1])</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;d_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">setObjective</span><span class="p">(</span><span class="n">grb</span><span class="o">.</span><span class="n">quicksum</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">MINIMIZE</span><span class="p">)</span>

    <span class="c1"># Aux vars - distance between (x, y)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;dx_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="n">ub</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
        <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;dy_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="n">ub</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
    <span class="c1"># Aux vars - distance from (x, y) to the center</span>
    <span class="n">rx</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">ry</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">rx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;rx_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="n">ub</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
        <span class="n">ry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;ry_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="n">ub</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>

    <span class="c1"># Constraints =============================================================</span>
    <span class="c1"># Aux constr - dx dy</span>
    <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">anchor</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">anchor</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)]</span> <span class="o">==</span> <span class="n">anchor</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)])</span>
    <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dy</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)]</span> <span class="o">==</span> <span class="n">anchor</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)])</span>

    <span class="c1"># Aux constr - rx ry</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">rx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">anchor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">ry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">anchor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Distance btw visits</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addQConstr</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># model.addQConstr(dx[i] ** 2 + dy[i] ** 2 &gt;= CONST_EPSILON)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addQConstr</span><span class="p">(</span><span class="n">rx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">circles</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">model</span><span class="o">.</span><span class="n">modelSense</span> <span class="o">=</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">MINIMIZE</span>
    <span class="c1"># model.write(&quot;SOCP.lp&quot;)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>

    <span class="c1"># Post-processing =========================================================</span>
    <span class="n">ofv</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">startPt</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">OPTIMAL</span><span class="p">):</span>
        <span class="n">solType</span> <span class="o">=</span> <span class="s1">&#39;IP_Optimal&#39;</span>
        <span class="n">ofv</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">getObjective</span><span class="p">()</span><span class="o">.</span><span class="n">getValue</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
        <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endPt</span><span class="p">)</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="n">ofv</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">ofv</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">grb</span><span class="o">.</span><span class="n">GRB</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">TIME_LIMIT</span><span class="p">):</span>
        <span class="n">solType</span> <span class="o">=</span> <span class="s1">&#39;IP_TimeLimit&#39;</span>
        <span class="n">ofv</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">ObjVal</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
        <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endPt</span><span class="p">)</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">MIPGap</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">ObjBoundC</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">ObjVal</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="n">path</span><span class="p">,</span>
        <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="n">ofv</span><span class="p">,</span>
        <span class="s1">&#39;runtime&#39;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">Runtime</span>
    <span class="p">}</span>
 
<span class="k">def</span> <span class="nf">_circle2CirclePathCOPT</span><span class="p">(</span><span class="n">startPt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">endPt</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="n">circles</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">outputFlag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">env</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">coptpy</span> <span class="k">as</span> <span class="nn">cp</span>
        <span class="n">envconfig</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">EnvrConfig</span><span class="p">()</span>
        <span class="n">envconfig</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;nobanner&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
        <span class="n">AVAIL_SOLVER</span> <span class="o">=</span> <span class="s1">&#39;COPT&#39;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">env</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">env</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Envr</span><span class="p">(</span><span class="n">envconfig</span><span class="p">)</span>
    <span class="k">except</span><span class="p">(</span><span class="ne">ImportError</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ERROR: Cannot find COPT&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">createModel</span><span class="p">(</span><span class="s2">&quot;SOCP&quot;</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">COPT</span><span class="o">.</span><span class="n">Param</span><span class="o">.</span><span class="n">Logging</span><span class="p">,</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">outputFlag</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">COPT</span><span class="o">.</span><span class="n">Param</span><span class="o">.</span><span class="n">LogToConsole</span><span class="p">,</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">outputFlag</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Decision variables ======================================================</span>
    <span class="c1"># anchor starts from startPt, in between are a list of circles, ends with endPt</span>
    <span class="n">anchor</span> <span class="o">=</span> <span class="p">[</span><span class="n">startPt</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)):</span>
        <span class="n">anchor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">])</span>
    <span class="n">anchor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endPt</span><span class="p">)</span>

    <span class="n">allX</span> <span class="o">=</span> <span class="p">[</span><span class="n">startPt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">endPt</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">allY</span> <span class="o">=</span> <span class="p">[</span><span class="n">startPt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">endPt</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)):</span>
        <span class="n">allX</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;radius&#39;</span><span class="p">])</span>
        <span class="n">allX</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;radius&#39;</span><span class="p">])</span>
        <span class="n">allY</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;radius&#39;</span><span class="p">])</span>
        <span class="n">allY</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">circles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;radius&#39;</span><span class="p">])</span>
    <span class="n">lbX</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">allX</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">lbY</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">allY</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">ubX</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">allX</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">ubY</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">allY</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Decision variables ======================================================</span>
    <span class="c1"># NOTE: x, y index starts by 1</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">COPT</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;x_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="n">lbX</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">ubX</span><span class="p">)</span>
        <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">COPT</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;y_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="n">lbY</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">ubY</span><span class="p">)</span>
    <span class="c1"># Distance from ((xi, yi)) to (x[i + 1], y[i + 1]), </span>
    <span class="c1"># where startPt = (x[0], y[0]) and endPt = (x[len(circles) + 1], y[len(circles) + 1])</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">COPT</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;d_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
    <span class="c1"># Aux vars - distance between (x, y)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">COPT</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;dx_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="n">ub</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
        <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">COPT</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;dy_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="n">ub</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
    <span class="c1"># Aux vars - distance from (x, y) to the center</span>
    <span class="n">rx</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">ry</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">rx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">COPT</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;rx_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="n">ub</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
        <span class="n">ry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">COPT</span><span class="o">.</span><span class="n">CONTINUOUS</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;ry_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="n">ub</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>

    <span class="n">model</span><span class="o">.</span><span class="n">setObjective</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">quicksum</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">cp</span><span class="o">.</span><span class="n">COPT</span><span class="o">.</span><span class="n">MINIMIZE</span><span class="p">)</span>

    <span class="c1"># Distance constraints ====================================================</span>
    <span class="c1"># Aux constr - dx dy</span>
    <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">anchor</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">anchor</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)]</span> <span class="o">==</span> <span class="n">anchor</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)])</span>
    <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">dy</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)]</span> <span class="o">==</span> <span class="n">anchor</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)])</span>
    <span class="c1"># Aux constr - rx ry</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">rx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">anchor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">ry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">anchor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Distance btw visits</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addQConstr</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">addQConstr</span><span class="p">(</span><span class="n">rx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">circles</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># model.write(&quot;SOCP.lp&quot;)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

    <span class="c1"># Post-processing =========================================================</span>
    <span class="n">ofv</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">startPt</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">cp</span><span class="o">.</span><span class="n">COPT</span><span class="o">.</span><span class="n">OPTIMAL</span><span class="p">):</span>
        <span class="n">solType</span> <span class="o">=</span> <span class="s1">&#39;IP_Optimal&#39;</span>
        <span class="n">ofv</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">getObjective</span><span class="p">()</span><span class="o">.</span><span class="n">getValue</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
        <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endPt</span><span class="p">)</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="n">ofv</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">ofv</span>
        <span class="n">runtime</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">SolvingTime</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">cp</span><span class="o">.</span><span class="n">COPT</span><span class="o">.</span><span class="n">TIMEOUT</span><span class="p">):</span>
        <span class="n">solType</span> <span class="o">=</span> <span class="s1">&#39;IP_TimeLimit&#39;</span>
        <span class="n">ofv</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">ObjVal</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
        <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endPt</span><span class="p">)</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">BestGap</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">BestBnd</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">BestObj</span>
        <span class="n">runtime</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">SolvingTime</span>
    <span class="n">realDist</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="n">path</span><span class="p">,</span>
        <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="n">ofv</span>
    <span class="p">}</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">vrpSolver 0.0.56 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">vrpSolver.geometry</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Lan Peng.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>
  </body>
</html>